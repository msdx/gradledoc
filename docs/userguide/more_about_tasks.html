<html>
<head>
	<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>第十五章. 任务详述 - Chapter&nbsp;15.&nbsp;More about Tasks</title>
	<link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css">
	<link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css">
	<link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css">
	<meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
	<link rel="home" href="userguide.html" title="Gradle 用户指南">
	<link rel="up" href="userguide.html" title="Gradle 用户指南">
	<link rel="prev" href="tutorial_this_and_that.html" title="第十四章. 教程 - 杂七杂八">
	<link rel="next" href="working_with_files.html" title="第十六章. 使用文件"></head>
<body>
	<div class="navheader">
		<div>
			<div class="navbar">
				<a xmlns:xslthl="http://xslthl.sf.net" href="tutorial_this_and_that.html" title="第十四章. 教程 - 杂七杂八">上一章</a>
				<span>|</span>
				<a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
				<span>|</span>
				<a xmlns:xslthl="http://xslthl.sf.net" href="working_with_files.html" title="第十六章. 使用文件">下一章</a>
			</div>
		</div>
	</div>
	<div class="chapter">
		<div class="titlepage">
			<div>
				<div>
				 <h1 xmlns:xslthl="http://xslthl.sf.net">
            <a name="more_about_tasks"></a>第十五章. 任务详述</h1>
					<h3 xmlns:xslthl="http://xslthl.sf.net">
						<a name="more_about_tasks"></a>
						Chapter&nbsp;15.&nbsp;More about Tasks
					</h3>
				</div>
			</div>
		</div>
		<p>在入门教程 （
      <a class="xref" href="tutorial_using_tasks.html">第 6 章，
      <i>构建脚本基础</i></a>）
      中，你已经学习了如何创建简单的任务。之后您还学习了如何将其他行为添加到这些任务中。并且你已经学会了如何创建任务之间的依赖。这都是简单的任务。但
      Gradle 让任务的概念更深远。Gradle 支持
      <em class="firstterm">增强的任务</em>，也就是，有自己的属性和方法的任务。这是真正的与你所使用的
      Ant 目标（target）的不同之处。这种增强的任务可以由你提供，或由 Gradle 提供。<br/>
			In the introductory tutorial (
			<a class="xref" href="tutorial_using_tasks.html">
				Chapter&nbsp;6, <i>Build Script Basics</i>
			</a>
			) you have learned how to
        create simple tasks. You have also learned how to add additional behavior to these tasks later on. And you have
        learned how to create dependencies between tasks. This was all about simple tasks. But Gradle takes the concept
        of tasks further. Gradle supports <em class="firstterm">enhanced tasks</em>
			, that is, tasks which have their own
        properties and methods. This is really different to what you are used to with Ant targets. Such enhanced tasks are
        either provided by you or are provided by Gradle.
		</p>
		<div class="section">
			<div class="titlepage">
				<div>
					<div> <h2 class="title">
              <a name="N10CBF"></a>15.1. 定义任务</h2>
						<h4 class="title">
							<a name="N10CBF"></a>
							15.1.&nbsp;Defining tasks
						</h4>
					</div>
				</div>
			</div>
			<p>在
        <a class="xref" href="tutorial_using_tasks.html">第 6 章，
        <i>构建脚本基础</i></a>
        中我们已经看到如何通过关键字这种风格来定义任务。在某些情况中，你可能需要使用这种关键字风格的几种不同的变式。例如，在表达式中不能用这种关键字风格。<br/>
				We have already seen how to define tasks using a keyword style in
				<a class="xref" href="tutorial_using_tasks.html">
					Chapter&nbsp;6, <i>Build Script Basics</i>
				</a>
				.
            There are a few variations on this style, which you may need to use in certain situations. For example,
            the keyword style does not work in expressions.
			</p>
			<div class="example">
				<a name="defineAsExpression"></a>
				<p class="title"> <b>示例 15.1. 定义任务</b><br/> <b>Example&nbsp;15.1.&nbsp;Defining tasks</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task(hello) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

task(copy, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}</pre>
				</div>
			</div>
			<br class="example-break">
			<p>您还可以使用字符串作为任务名称：<br/>You can also use strings for the task names:</p>
			<div class="example">
				<a name="defineUsingStringTaskNames"></a>
				<p class="title"> <b>示例 15.2. 定义任务 — — 使用字符串作为任务名称</b><br/><b>Example&nbsp;15.2.&nbsp;Defining tasks - using strings for task names</b> 
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>) &lt;&lt;
{
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}</pre>
				</div>
			</div>
			<br class="example-break">
			<p>对于定义任务，有一种替代的语法你可能更愿意使用：<br/>
				There is an alternative syntax for defining tasks, which you may prefer to use:
			</p>
			<div class="example">
				<a name="addToTaskContainer"></a>
				<p class="title"> <b>示例 15.3. 使用替代语法定义任务</b><br/>
					<b>Example&nbsp;15.3.&nbsp;Defining tasks with alternative syntax</b> 
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">tasks.create(name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

tasks.create(name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}</pre>
				</div>
			</div>
			<br class="example-break">
			<p>在这里我们将任务添加到
        <code class="literal">tasks</code>集合。关于
        <code class="literal">create ()</code>方法的更多变化可以看看
        <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top">
          <code class="classname">TaskContainer</code>
        </a>。<br/>
				Here we add tasks to the
				<code class="literal">tasks</code>
				collection. Have a look at
				<a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top">
					<code class="classname">TaskContainer</code>
				</a>
				for more variations of the
				<code class="literal">create()</code>
				method.
			</p>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div>  <h2 class="title">
              <a name="N10CF6"></a>15.2. 定位任务</h2>
						<h4 class="title">
							<a name="N10CF6"></a>
							15.2.&nbsp;Locating tasks
						</h4>
					</div>
				</div>
			</div>
			<p>你经常需要在构建文件中查找你所定义的任务，例如，为了去配置或是依赖它们。对这样的情况，有很多种方法。首先，每个任务都可作为项目的一个属性，并且使用任务名称作为这个属性名称：<br/>
				You often need to locate the tasks that you have defined in the build file, for example, to configure them
            or use them for dependencies. There are a number of ways of doing this. Firstly, each task is available as
            a property of the project, using the task name as the property name:
			</p>
			<div class="example">
				<a name="accessAsProperty"></a>
				<p class="title"><b>示例 15.4. 以属性方式访问任务</b><br/>
					<b>Example&nbsp;15.4.&nbsp;Accessing tasks as properties</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task hello

println hello.name
println project.hello.name</pre>
				</div>
			</div>
			<br class="example-break">
			<p>任务也可以通过
        <code class="literal">tasks</code>集合来访问。<br/>
				Tasks are also available through the
				<code class="literal">tasks</code>
				collection.
			</p>
			<div class="example">
				<a name="accessFromTaskContainer"></a>
				<p class="title"> <b>示例 15.5. 通过tasks集合访问任务</b><br/>
					<b>Example&nbsp;15.5.&nbsp;Accessing tasks via tasks collection</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task hello

println tasks.hello.name
println tasks[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>].name</pre>
				</div>
			</div>
			<br class="example-break">
			<p>您可以从任何项目中，使用
        <code class="literal">tasks.getByPath()</code>方法获取任务路径并且通过这个路径来访问任务。你可以用任务名称，相对路径或者是绝对路径作为参数调用
        <code class="literal">getByPath()</code>方法。<br/>
				You can access tasks from any project using the task's path using the
				<code class="literal">tasks.getByPath()</code>
				method. You can call the
				<code class="literal">getByPath()</code>
				method with a task name, or a relative path, or an
            absolute path.
			</p>
			<div class="example">
				<a name="accessUsingPath"></a>
				<p class="title"> <b>示例15.6. 通过路径访问任务</b><br/>
					<b>Example&nbsp;15.6.&nbsp;Accessing tasks by path</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectA'</span>) {
    task hello
}

task hello

println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectA:hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectA:hello'</span>).path</pre>
					<p> <strong class="userinput">
              <code>gradle -q hello</code>
            </strong>的输出结果<br/>
						Output of <strong class="userinput"><code>gradle -q hello</code></strong> 
					</p>
					<pre class="screen">&gt; gradle -q hello
:hello
:hello
:projectA:hello
:projectA:hello</pre>
				</div>
			</div>
			<br class="example-break">
			<p>有关查找任务的更多选项，可以看一下
        <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top">
          <code class="classname">TaskContainer</code>
        </a>。<br/>
				Have a look at
				<a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top">
					<code class="classname">TaskContainer</code>
				</a>
				for more options for locating tasks.
			</p>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div><h2 class="title">
              <a name="sec:configuring_tasks"></a>15.3. 配置任务</h2>
						<h4 class="title">
							<a name="sec:configuring_tasks"></a>
							15.3.&nbsp;Configuring tasks
						</h4>
					</div>
				</div>
			</div>
			<p>作为一个例子，让我们看看由 Gradle 提供的
        <code class="classname">Copy</code>任务。若要创建
        <code class="classname">Copy</code>任务，您可以在构建脚本中声明：<br/>
				As an example, let's look at the
				<code class="classname">Copy</code>
				task provided by Gradle. To create a
				<code class="classname">Copy</code>
				task for your build, you can declare in your build script:
			</p>
			<div class="example">
				<a name="declareTask"></a>
				<p class="title"><b>示例 15.7. 创建一个复制任务</b><br/>
					<b>Example&nbsp;15.7.&nbsp;Creating a copy task</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task myCopy(type: Copy)</pre>
				</div>
			</div>
			<br class="example-break">
			<p>上面的代码创建了一个什么都没做的复制任务。可以使用它的 API 来配置这个任务 （见
        <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top">
          <code class="classname">Copy</code>
        </a>）。下面的示例演示了几种不同的方式来实现相同的配置。<br/>
				This creates a copy task with no default behavior.
            The task can be configured using its API (see
				<a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top">
					<code class="classname">Copy</code>
				</a>
				).
			The following examples show several different ways to achieve the same configuration.
			</p>
			<div class="example">
				<a name="configureUsingVar"></a>
				<p class="title">   <b>示例 15.8. 配置任务的几种方式</b><br/>
					<b>Example&nbsp;15.8.&nbsp;Configuring a task - various ways</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">Copy myCopy = task(myCopy, type: Copy)
myCopy.from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
myCopy.into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
myCopy.include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)</pre>
				</div>
			</div>
			<br class="example-break">
			<p>这类似于我们通常在 Java 中配置对象的方式。您必须在每一次的配置语句重复上下文 （
        <code class="literal">myCopy</code>）。这显得很冗余并且很不好读。<br/>
				This is similar to the way we would normally configure objects in Java. You have to repeat the context
            (
				<code class="literal">myCopy</code>
				) in the configuration statement every time. This is a redundancy and not very
            nice to read.
			</p>
			<p>还有另一种配置任务的方式。它也保留了上下文，且可以说是可读性最强的。它是我们通常最喜欢的方式。<br/>
				There is another way of configuring a task. It also preserves the context and it is arguably the
            most readable. It is usually our favorite.
			</p>
			<div class="example">
				<a name="configureUsingClosure"></a>
				<p class="title"> <b>示例 15.9. 配置任务-使用闭包</b><br/>
					<b>Example&nbsp;15.9.&nbsp;Configuring a task - with closure</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task myCopy(type: Copy)

myCopy {
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}</pre>
				</div>
			</div>
			<br class="example-break">
			<p>这种方式适用于
        <span class="emphasis">
          <em>任何</em>
        </span>任务。该例子的第 3 行只是
        <code class="literal">tasks.getByName()</code>方法的简洁写法。特别要注意的是，如果您向
        <code class="literal">getByName()</code>方法传入一个闭包，这个闭包的应用是在
        <span class="emphasis">
          <em>配置</em>
        </span>这个任务的时候，而不是任务执行的时候。<br/>
				This works for
				<span class="emphasis"> <em>any</em>
				</span>
				task. Line 3 of the example is just a shortcut for the
				<code class="literal">tasks.getByName()</code>
				method. It is important to note that if you pass a closure to the
				<code class="literal">getByName()</code>
				method, this closure is applied to
				<span class="emphasis">
					<em>configure</em>
				</span>
				the task, not when
            the task executes.
			</p>
			<p>您也可以在定义一个任务的时候使用一个配置闭包。<br/>
				You can also use a configuration closure when you define a task.
			</p>
			<div class="example">
				<a name="defineAndConfigure"></a>
				<p class="title"><b>示例 15.10. 使用闭包定义任务</b><br/>
					<b>Example&nbsp;15.10.&nbsp;Defining a task with closure</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task copy(type: Copy) {
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}</pre>
				</div>
			</div>
			<br class="example-break"></div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div><h2 class="title">
              <a name="sec:adding_dependencies_to_tasks"></a>15.4. 对任务添加依赖</h2>
						<h4 class="title">
							<a name="sec:adding_dependencies_to_tasks"></a>
							15.4.&nbsp;Adding dependencies to a task
						</h4>
					</div>
				</div>
			</div>
			<p>定义任务的依赖关系有几种方法。在
        <a class="xref" href="tutorial_using_tasks.html#sec:task_dependencies">第 6.5
        章节，&quot;任务依赖&quot;</a>中，已经向你介绍了使用任务名称来定义依赖。任务的名称可以指向同一个项目中的任务，或者其他项目中的任务。要引用另一个项目中的任务，你需要把它所属的项目的路径作为前缀加到它的名字中。下面是一个示例，添加了从
        <code class="literal">projectA:taskX</code>到
        <code class="literal">projectB:taskY</code>的依赖关系：<br/>
				There are several ways you can define the dependencies of a task. In
				<a class="xref" href="tutorial_using_tasks.html#sec:task_dependencies">Section&nbsp;6.5, &ldquo;Task dependencies&rdquo;</a>
				you were introduced to defining dependencies using task names. Task names can refer to tasks in the same
            project as the task, or to tasks in other projects. To refer to a task in another project, you prefix the
            name of the task with the path of the project it belongs to. Below is an example which adds a dependency
            from
				<code class="literal">projectA:taskX</code>
				to
				<code class="literal">projectB:taskY</code>
				:
			</p>
			<div class="example">
				<a name="addDependencyUsingPath"></a>
				<p class="title">
					<b> <b>示例 15.11. 从另一个项目的任务上添加依赖</b><br/>
						Example&nbsp;15.11.&nbsp;Adding dependency on task from another project
					</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectA'</span>) {
    task taskX(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectB:taskY'</span>) &lt;&lt; {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectB'</span>) {
    task taskY &lt;&lt; {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
    }
}</pre>
					<p> <strong class="userinput">
              <code>gradle -q taskX</code>
            </strong>的输出结果<br/>
						Output of <strong class="userinput"><code>gradle -q taskX</code></strong> 
					</p>
					<pre class="screen">&gt; gradle -q taskX
taskY
taskX</pre>
				</div>
			</div>
			<br class="example-break">
			<p>您可以使用一个
        <code class="classname">Task</code>对象而不是任务名称来定义依赖，如下：<br/>
				Instead of using a task name, you can define a dependency using a
				<code class="classname">Task</code>
				object, as shown in this example:
			</p>
			<div class="example">
				<a name="addDependencyUsingTask"></a>
				<p class="title">   <b>示例 15.12. 使用 task 对象添加依赖</b><br/>
					<b>Example&nbsp;15.12.&nbsp;Adding dependency using task object</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}

task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.dependsOn taskY</pre>
					<p> <strong class="userinput">
              <code>gradle -q taskX</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskX
taskY
taskX</pre>
				</div>
			</div>
			<br class="example-break">
			<p>对于更高级的用法，您可以使用闭包来定义任务依赖。在计算依赖时，闭包会被传入正在计算依赖的任务。这个闭包应该返回一个<code class="classname">Task</code> 对象或是
        <code class="classname">Task</code> 对象的集合，返回值会被作为这个任务的依赖项。下面的示例是从
        <code class="literal">taskX</code>加入了项目中所有名称以
        <code class="literal">lib</code>开头的任务的依赖：<br/>
				For more advanced uses, you can define a task dependency using a closure. When evaluated, the closure is
            passed the task whose dependencies are being calculated. The closure should return a single
				<code class="classname">Task</code>
				or collection of
				<code class="classname">Task</code>
				objects, which are then treated
            as dependencies of the task. The following example adds a dependency from
				<code class="literal">taskX</code>
				to all the tasks in the project whose name starts with
				<code class="literal">lib</code>
				:
			</p>
			<div class="example">
				<a name="addDependencyUsingClosure"></a>
				<p class="title"> <b>示例 15.13. 使用闭包添加依赖</b><br/>
					<b>Example&nbsp;15.13.&nbsp;Adding dependency using closure</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}

taskX.dependsOn {
    tasks.findAll { task -&gt; task.name.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>) }
}

task lib1 &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib1'</span>
}

task lib2 &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib2'</span>
}

task notALib &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'notALib'</span>
}</pre>
					<p> <strong class="userinput">
              <code>gradle -q taskX</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskX
lib1
lib2
taskX</pre>
				</div>
			</div>
			<br class="example-break">
			<p>有关任务依赖的详细信息，请参阅
        <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top">
          <code class="classname">Task</code>
        </a>的 API。<br/>
				For more information about task dependencies, see the
				<a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top">
					<code class="classname">Task</code>
				</a>
				API.
			</p>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div>
					<h2 class="title">
              <a name="sec:ordering_tasks"></a>15.5. 任务排序</h2>
						<h4 class="title">
							<a name="sec:ordering_tasks"></a>
							15.5.&nbsp;Ordering tasks
						</h4>
					</div>
				</div>
			</div>
			<div class="note">
				<p>任务排序还是一个
          <a class="link" href="feature_lifecycle.html">孵化中</a>的功能。请注意此功能在以后的 Gradle
          版本中可能会改变。<br/>
					Task ordering is an
					<a class="link" href="feature_lifecycle.html">incubating</a>
					feature. Please be aware that this feature may change in later Gradle versions.
				</p>
			</div>
			<p>在某些情况下，控制两个任务的执行的
        <span class="emphasis">
          <em>顺序</em>
        </span>，而不引入这些任务之间的显式依赖，是很有用的。任务
        <span class="emphasis">
          <em>排序</em>
        </span>和任务
        <span class="emphasis">
          <em>依赖</em>
        </span>之间的主要区别是，排序规则不会影响那些任务的执行，而仅将执行的顺序。<br/>
				In some cases it is useful to control the
				<span class="emphasis">
					<em>order</em>
				</span>
				in which 2 tasks will execute, without introducing an explicit dependency between those tasks.
            The primary difference between a task
				<span class="emphasis">
					<em>ordering</em>
				</span>
				and a task
				<span class="emphasis">
					<em>dependency</em>
				</span>
				is that an ordering rule does not influence which tasks
            will be executed, only the order in which they will be executed.
			</p>
			<p>任务排序在许多情况下可能很有用：<br/>Task ordering can be useful in a number of scenarios:</p>
			<div class="itemizedlist">
				<ul class="itemizedlist">
					<li class="listitem">强制任务顺序执行： 如“build”永远不会在 "clean" 前面执行。<br/>
						Enforce sequential ordering of tasks: eg. 'build' never runs before 'clean'.
					</li>
					<li class="listitem">在构建中尽早进行构建验证：如，验证在开始发布的工作前有一个正确的证书。<br/>
						Run build validations early in the build: eg. validate I have the correct credentials before starting the work for a release build.
					</li>
					<li class="listitem">通过在长久验证前运行快速验证以得到更快的反馈：如，单元测试应在集成测试之前运行。<br/>
						Get feedback faster by running quick verification tasks before long verification tasks: eg. unit tests should run before integration tests.
					</li>
					<li class="listitem">一个任务聚合了某一特定类型的所有任务的结果：如，测试报告任务结合了所有执行的测试任务的输出。<br/>
						A task that aggregates the results of all tasks of a particular type: eg. test report task combines the outputs of all executed test tasks.
					</li>
				</ul>
			</div>
			<p>有两种排序规则是可用的：“
        <span class="emphasis">
          <em>必须在之后运行</em>
        </span>”和“
        <span class="emphasis">
          <em>应该在之后运行</em>
        </span>”。<br/>
				There are two ordering rules available: "
				<span class="emphasis">
					<em>must run after</em>
				</span>
				" and "
				<span class="emphasis">
					<em>should run after</em>
				</span>
				".
			</p>
			<p>通过使用 “ 必须在之后运行”的排序规则，您可以指定 
        <code class="literal">taskB</code> 必须总是运行在 
        <code class="literal">taskA</code> 之后，无论
        <code class="literal">taskA</code>和
        <code class="literal">taskB</code>这两个任务在什么时候被调度执行。这被表示为 
        <code class="literal">taskB.mustRunAfter(taskA)</code>
        。“应该在之后运行”的排序规则与其类似，但没有那么严格，因为它在两种情况下会被忽略。首先是如果使用这一规则引入了一个排序循环。其次，当使用并行执行，并且一个任务的所有依赖项除了任务应该在之后运行之外所有条件已满足，那么这个任务将会运行，不管它的“应该在之后运行”的依赖项是否已经运行了。当倾向于更快的反馈时，会使用“应该在之后运行”的规则，因为这种排序很有帮助但要求不严格。<br/>
				By using 'must run after" ordering rule you can specify that
				<code class="literal">taskB</code>
				must always run after
				<code class="literal">taskA</code>
				,
            whenever both
				<code class="literal">taskA</code>
				and
				<code class="literal">taskB</code>
				are scheduled for execution. This is expressed as
				<code class="literal">taskB.mustRunAfter(taskA)</code>
				. The 'should run after' ordering rule is similar but less strict as it will be ignored in two situations. Firstly if using that rule introduces an ordering cycle. Secondly when using parallel execution and all dependencies of a task have been satisfied apart from should run after then this task will be run regardless of weather its 'should run after' dependencies have been run or not. You would use 'should run after' rule when ordering preference for faster feedback, where the ordering is helpful but not strictly required.
			</p>
			<p>目前使用这些规则仍有可能出现
        <code class="literal">taskA</code>执行而
        <code class="literal">taskB</code> 没有执行，或者
        <code class="literal">taskB</code>执行而
        <code class="literal">taskA</code> 没有执行。<br/>
				With these rules present it is still possible to execute
				<code class="literal">taskA</code>
				without
				<code class="literal">taskB</code>
				and vice-versa.
			</p>
			<div class="example">
				<a name="mustRunAfter"></a>
				<p class="title">
					<b>示例 15.14. 添加“必须在之后运行”的任务排序</b><br/><b> 
						Example&nbsp;15.14.&nbsp;Adding a 'must run after' task ordering
					</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
taskY.mustRunAfter taskX</pre>
					<p> <strong class="userinput">
              <code>gradle -q taskY taskX</code>
            </strong> 的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskY taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre>
				</div>
			</div>
			<br class="example-break">
			<div class="example">
				<a name="shouldRunAfter"></a>
				<p class="title"> <b>示例 15.15. 添加“应该在之后运行”的任务排序</b><br/>
					<b>
						Example&nbsp;15.15.&nbsp;Adding a 'should run after' task ordering
					</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
taskY.shouldRunAfter taskX</pre>
					<p><strong class="userinput">
              <code>gradle -q taskY taskX</code>
            </strong> 的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskY taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre>
				</div>
			</div>
			<br class="example-break">
			<p>在上面的例子中，它仍有可能执行
        <code class="literal">taskY</code>而不会导致
        <code class="literal">taskX</code>也运行：<br/>
				In the examples above, it is still possible to execute
				<code class="literal">taskY</code>
				without causing
				<code class="literal">taskX</code>
				to run:
			</p>
			<div class="example">
				<a name="mustRunAfterSingleTask"></a>
				<p class="title"><b>示例 15.16. 任务排序并不意味着任务执行</b><br/>
					<b>
						Example&nbsp;15.16.&nbsp;Task ordering does not imply task execution
					</b>
				</p>
				<div class="example-contents">
					<p> <strong class="userinput">
              <code>gradle -q taskY</code>
            </strong> 的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskY</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskY
taskY</pre>
				</div>
			</div>
			<br class="example-break">
			<p>如果想指定两个任务之间的“必须在之后运行”和“应该在之后运行”排序，可以使用
        <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object...)"
        target="_top">
          <code class="classname">Task.mustRunAfter()</code>
        </a>和
        <a class="ulink" href="../javadoc/org/gradle/api/Task.html#shouldRunAfter(java.lang.Object...)" target="_top">
          <code class="classname">Task.shouldRunAfter()</code>
        </a>方法。这些方法接受一个任务实例、 任务名称或
        <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object...)" target="_top">
          <code class="classname">Task.dependsOn()</code>
        </a>所接受的任何其他输入作为参数。<br/>
				To specify a "must run after" or "should run after" ordering between 2 tasks, you use the
				<a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object...)" target="_top">
					<code class="classname">Task.mustRunAfter()</code>
				</a>
				and
				<a class="ulink" href="../javadoc/org/gradle/api/Task.html#shouldRunAfter(java.lang.Object...)" target="_top">
					<code class="classname">Task.shouldRunAfter()</code>
				</a>
				methods.
            These method accept a task instance, a task name or any other input accepted by
				<a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object...)" target="_top">
					<code class="classname">Task.dependsOn()</code>
				</a>
				.
			</p>
			<p>请注意“
        <code class="literal">B.mustRunAfter(A)</code>”或“
                <code class="literal">B.shouldRunAfter(A)</code>”并不意味着这些任务之间的任何执行上的依赖关系：<br/>
				Note that "
				<code class="literal">B.mustRunAfter(A)</code>
				" or "
				<code class="literal">B.shouldRunAfter(A)</code>
				" does not imply any execution dependency between the tasks:
			</p>
			<div class="itemizedlist">
				<ul class="itemizedlist">
					<li class="listitem">它是可以独立地执行任务
            <code class="literal">A</code>和
            <code class="literal">B</code> 的。排序规则仅在这两项任务计划执行时起作用。<br/>
						It is possible to execute tasks
						<code class="literal">A</code>
						and
						<code class="literal">B</code>
						independently. The ordering rule only has an effect when both tasks are scheduled for execution.
					</li>
					<li class="listitem">当
            <code class="literal">--continue</code>参数运行时，可能会是
            <code class="literal">A</code>执行失败后
            <code class="literal">B</code>执行了。<br/>
						When run with
						<code class="literal">--continue</code>
						, it is possible for
						<code class="literal">B</code>
						to execute in the event that
						<code class="literal">A</code>
						fails.
					</li>
				</ul>
			</div>
			<p>如之前所述，如果“应该在之后运行”的排序规则引入了排序循环，那么它将会被忽略。<br/>
				As mentioned before 'should run after' ordering rule will be ignored if it introduces an ordering cycle:
			</p>
			<div class="example">
				<a name="shouldRunAfterWithCycle"></a>
				<p class="title"> <b>示例 15.17. 当引入循环时，“应该在其之后运行”的任务排序会被忽略</b><br/>
					<b>
						Example&nbsp;15.17.&nbsp;A 'should run after' task ordering is ignored if it introduces an ordering cycle
					</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
task taskZ &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskZ'</span>
}
taskX.dependsOn taskY
taskY.dependsOn taskZ
taskZ.shouldRunAfter taskX</pre>
					<p>  <strong class="userinput">
              <code>gradle -q taskX</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskX
taskZ
taskY
taskX</pre>
				</div>
			</div>
			<br class="example-break"></div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div>  <h2 class="title">
              <a name="N10E91"></a>15.6. 向任务添加描述</h2>
						<h4 class="title">
							<a name="N10E91"></a>
							15.6.&nbsp;Adding a description to a task
						</h4>
					</div>
				</div>
			</div>
			<p>你可以向你的任务添加描述。例如，当执行
        <strong class="userinput">
          <code>gradle tasks</code>
        </strong>时显示这个描述。<br/>
				You can add a description to your task. This description is for example displayed when executing
				<strong class="userinput">
					<code>gradle tasks</code>
				</strong>
				.
			</p>
			<div class="example">
				<a name="describeTask"></a>
				<p class="title">  <b>示例 15.18. 向任务添加描述</b><br/>
					<b>Example&nbsp;15.18.&nbsp;Adding a description to a task</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task copy(type: Copy) {
   description <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Copies the resource directory to the target directory.'</span>
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}</pre>
				</div>
			</div>
			<br class="example-break"></div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div><h2 class="title">
              <a name="N10EA3"></a>15.7. 替换任务</h2>
						<h4 class="title">
							<a name="N10EA3"></a>
							15.7.&nbsp;Replacing tasks
						</h4>
					</div>
				</div>
			</div>
			<p>有时您想要替换一个任务。例如，您想要把通过 Java
        插件添加的一个任务与不同类型的一个自定义任务进行交换。你可以这样实现：<br/>
				Sometimes you want to replace a task. For example if you want to exchange a task added by the Java plugin
            with a custom task of a different type. You can achieve this with:
			</p>
			<div class="example">
				<a name="replaceTask"></a>
				<p class="title">    <b>示例 15.19. 重写任务</b><br/>
					<b>Example&nbsp;15.19.&nbsp;Overwriting a task</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task copy(type: Copy)

task copy(overwrite: true) &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'I am the new one.'</span>)
}</pre>
					<p>  <strong class="userinput">
              <code>gradle -q copy</code>
            </strong> 的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q copy</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q copy
I am the new one.</pre>
				</div>
			</div>
			<br class="example-break">
			<p>在这里我们用一个简单的任务替换
        <code class="literal">Copy</code>类型的任务。当创建这个简单的任务时，您必须将
        <code class="literal">overwrite</code>属性设置为 true。否则 Gradle
        将抛出异常，说这种名称的任务已经存在。<br/>
				Here we replace a task of type
				<code class="literal">Copy</code>
				with a simple task. When creating the simple
            task, you have to set the
				<code class="literal">overwrite</code>
				property to true. Otherwise Gradle throws an
            exception, saying that a task with such a name already exists.
			</p>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div> <h2 class="title">
              <a name="N10EC0"></a>15.8. 跳过任务</h2>
						<h4 class="title">
							<a name="N10EC0"></a>
							15.8.&nbsp;Skipping tasks
						</h4>
					</div>
				</div>
			</div>
			<p>Gradle 提供多种方式来跳过任务的执行。<br/>Gradle offers multiple ways to skip the execution of a task.</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>
						 <h3 class="title">
                <a name="N10EC5"></a>15.8.1. 使用断言</h3>
							<h5 class="title">
								<a name="N10EC5"></a>
								15.8.1.&nbsp;Using a predicate
							</h5>
						</div>
					</div>
				</div>
				<p>你可以使用
          <code class="literal">onlyIf()</code>方法将断言附加到一项任务中。如果断言结果为
          true，才会执行任务的操作。你可以用一个闭包来实现断言。闭包会作为一个参数传给任务，并且任务应该执行时返回true，或任务应该跳过时返回false。断言只在任务要执行前才计算。<br/>
					You can use the
					<code class="literal">onlyIf()</code>
					method to attach a predicate to a task. The task's
                actions are only executed if the predicate evaluates to true. You implement the predicate as a closure.
                The closure is passed the task as a parameter, and should return true if the task should execute
                and false if the task should be skipped. The predicate is evaluated just before the task is due
                to be executed.
				</p>
				<div class="example">
					<a name="taskOnlyIf"></a>
					<p class="title">  <b>示例 15.20. 使用断言跳过一个任务</b><br/>
						<b>Example&nbsp;15.20.&nbsp;Skipping a task using a predicate</b>
					</p>
					<div class="example-contents">
						<p>
							<code class="filename">build.gradle</code>
						</p>
						<pre class="programlisting">task hello &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello world'</span>
}

hello.onlyIf { !project.hasProperty(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'skipHello'</span>) }</pre>
						<p> <strong class="userinput">
                <code>gradle hello -PskipHello</code>
              </strong>的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle hello -PskipHello</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle hello -PskipHello
:hello SKIPPED

BUILD SUCCESSFUL

Total time: 1 secs</pre>
					</div>
				</div>
				<br class="example-break"></div>
			<div class="section">
				<div class="titlepage">
					<div>
						<div> <h3 class="title">
                <a name="N10EDD"></a>15.8.2. 使用 StopExecutionException</h3>
							<h5 class="title">
								<a name="N10EDD"></a>
								15.8.2.&nbsp;Using StopExecutionException
							</h5>
						</div>
					</div>
				</div>
				<p>如果跳过任务的规则不能与断言同时表达，您可以使用
          <a class="ulink" href="../javadoc/org/gradle/api/tasks/StopExecutionException.html" target="_top">
            <code class="classname">StopExecutionException</code>
          </a>。如果一个操作（action）抛出了此异常，那么这个操作（action）接下来的行为和这个任务的其他
          操作（action）都会被跳过。构建会继续执行下一个任务。<br/>
					If the rules for skipping a task can't be expressed with predicate, you can use the
					<a class="ulink" href="../javadoc/org/gradle/api/tasks/StopExecutionException.html" target="_top">
						<code class="classname">StopExecutionException</code>
					</a>
					. If this exception is thrown by an action,
            the further execution of this action as well as the execution of
            any following action of this task is skipped. The build continues with executing the next task.
				</p>
				<div class="example">
					<a name="stopExecutionException"></a>
					<p class="title"> <b>示例 15.21. 使用 StopExecutionException 跳过任务</b><br/>
						<b>
							Example&nbsp;15.21.&nbsp;Skipping tasks with StopExecutionException
						</b>
					</p>
					<div class="example-contents">
						<p>
							<code class="filename">build.gradle</code>
						</p>
						<pre class="programlisting">task compile &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'We are doing the compile.'</span>
}

compile.doFirst {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Here you would put arbitrary conditions in real life. But we use this as an integration test, so we want defined behavior.</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (true) { <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">throw</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> StopExecutionException() }
}
task myTask(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>) &lt;&lt; {
   println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'I am not affected'</span>
}</pre>
						<p> <strong class="userinput">
                <code>gradle -q myTask</code>
              </strong> 的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle -q myTask</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle -q myTask
I am not affected</pre>
					</div>
				</div>
				<br class="example-break">
				<p>如果您使用由 Gradle
          提供的任务，那么此功能将非常有用。它允许您向一个任务的内置操作中添加执行
          <span class="emphasis">
            <em>条件</em>
          </span>。
          <sup>[
          <a href="#ftn.N10EFC" name="N10EFC" class="footnote">7</a>]</sup><br/>
					This feature is helpful if you work with tasks provided by Gradle. It allows you to add
					<span class="emphasis">
						<em>conditional</em>
					</span>
					execution of the built-in actions of such a task. <sup>[
						<a href="#ftn.N10EFC" name="N10EFC" class="footnote">7</a>
						]</sup> 
				</p>
			</div>
			<div class="section">
				<div class="titlepage">
					<div>
						<div> <h3 class="title">
                <a name="N10F06"></a>15.8.3. 启用和禁用任务</h3>
							<h5 class="title">
								<a name="N10F06"></a>
								15.8.3.&nbsp;Enabling and disabling tasks
							</h5>
						</div>
					</div>
				</div>
				<p>每一项任务有一个默认值为
          <code class="literal">true</code>的
          <code class="literal">enabled</code>标记。将它设置为
          <code class="literal">false</code>，可以不让这个任务的任何操作执行。<br/>
					Every task has also an
					<code class="literal">enabled</code>
					flag which defaults to
					<code class="literal">true</code>
					. Setting it to
					<code class="literal">false</code>
					prevents the
            execution of any of the task's actions.
				</p>
				<div class="example">
					<a name="disableTask"></a>
					<p class="title">  <b>示例 15.22. 启用和禁用任务</b><br/>
						<b>Example&nbsp;15.22.&nbsp;Enabling and disabling tasks</b>
					</p>
					<div class="example-contents">
						<p>
							<code class="filename">build.gradle</code>
						</p>
						<pre class="programlisting">task disableMe &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'This should not be printed if the task is disabled.'</span>
}
disableMe.enabled = false</pre>
						<p> <strong class="userinput">
                <code>Gradle disableMe</code>
              </strong>的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle disableMe</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle disableMe
:disableMe SKIPPED

BUILD SUCCESSFUL

Total time: 1 secs</pre>
					</div>
				</div>
				<br class="example-break"></div>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div>  <h2 class="title">
              <a name="sec:up_to_date_checks"></a>15.9. 跳过处于最新状态的任务</h2>
						<h4 class="title">
							<a name="sec:up_to_date_checks"></a>
							15.9.&nbsp;Skipping tasks that are up-to-date
						</h4>
					</div>
				</div>
			</div>
			<p>如果您使用 Gradle 自带的任务，如 Java 插件所添加的任务的话，你可能已经注意到 Gradle
        将跳过处于最新状态的任务。这种行在您自己定义的任务上也有效，而不仅仅是内置任务。<br/>
				If you are using one of the tasks that come with Gradle, such as a task added by the Java plugin,
            you might have noticed that Gradle will skip tasks that are up-to-date. This behaviour is also available
            for your tasks, not just for built-in tasks.
			</p>
			<div class="section">
				<div class="titlepage">
					<div>
						<div>    <h3 class="title">
                <a name="sec:task_inputs_outputs"></a>15.9.1. 声明一个任务的输入和输出</h3>
							<h5 class="title">
								<a name="sec:task_inputs_outputs"></a>
								15.9.1.&nbsp;Declaring a task's inputs and outputs
							</h5>
						</div>
					</div>
				</div>
				<p>让我们来看一个例子。在这里我们的任务从一个 XML
          源文件生成多个输出文件。让我们运行它几次。<br/>
					Let's have a look at an example. Here our task generates several output files from a source XML file. Let's
                run it a couple of times.
				</p>
				<div class="example">
					<a name="generatorTask"></a>
					<p class="title">   <b>示例 15.23. 一个生成任务</b><br/>
						<b>Example&nbsp;15.23.&nbsp;A generator task</b>
					</p>
					<div class="example-contents">
						<p>
							<code class="filename">build.gradle</code>
						</p>
						<pre class="programlisting">task transform {
    ext.srcFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'mountains.xml'</span>)
    ext.destDir = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(buildDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'generated'</span>)
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Transforming source file."</span>
        destDir.mkdirs()
        def mountains = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> XmlParser().parse(srcFile)
        mountains.mountain.each { mountain -&gt;
            def name = mountain.name[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def height = mountain.height[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def destFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(destDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${name}.txt"</span>)
            destFile.text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$name -&gt; ${height}\n"</span>
        }
    }
}</pre>
						<p> <strong class="userinput">
                <code>gradle transform</code>
              </strong>的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle transform</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre>
						<p><strong class="userinput">
                <code>gradle transform</code>
              </strong>的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle transform</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre>
					</div>
				</div>
				<br class="example-break">
				<p>请注意 Gradle
          第二次执行执行这项任务时，即使什么都未作改变，也没有跳过该任务。我们的示例任务被用一个操作（action）闭包来定义。Gradle 不知道这个闭包做了什么，也无法自动判断这个任务是否为最新状态。若要使用 Gradle 的最新状态（up-to-date）检查，您需要声明这个任务的输入和输出。<br/>
					Notice that Gradle executes this task a second time, and does not skip the task even though nothing has
                changed. Our example task was defined using an action closure. Gradle has no idea what the closure does and
                cannot automatically figure out whether the task is up-to-date or not. To use Gradle's up-to-date checking,
                you need to declare the inputs and outputs of the task.
				</p>
				<p>每个任务都有一个
          <code class="literal">inputs</code>和
          <code class="literal">outputs</code>的属性，用来声明任务的输入和输出。下面，我们修改了我们的示例，声明它将
          XML 源文件作为输入，并产生输出到一个目标目录。让我们运行它几次。<br/>
					Each task has an
					<code class="literal">inputs</code>
					and
					<code class="literal">outputs</code>
					property, which you use to
                declare the inputs and outputs of the task. Below, we have changed our example to declare that it takes
                the source XML file as an input and produces output to a destination directory. Let's run it a couple
                of times.
				</p>
				<div class="example">
					<a name="incrementalTask"></a>
					<p class="title"> <b>示例 15.24. 声明一个任务的输入和输出</b><br/>
						<b>
							Example&nbsp;15.24.&nbsp;Declaring the inputs and outputs of a task
						</b>
					</p>
					<div class="example-contents">
						<p>
							<code class="filename">build.gradle</code>
						</p>
						<pre class="programlisting">task transform {
    ext.srcFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'mountains.xml'</span>)
    ext.destDir = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(buildDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'generated'</span>)
    inputs.file srcFile
    outputs.dir destDir
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Transforming source file."</span>
        destDir.mkdirs()
        def mountains = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> XmlParser().parse(srcFile)
        mountains.mountain.each { mountain -&gt;
            def name = mountain.name[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def height = mountain.height[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def destFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(destDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${name}.txt"</span>)
            destFile.text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$name -&gt; ${height}\n"</span>
        }
    }
}</pre>
						<p> <strong class="userinput">
                <code>gradle transform</code>
              </strong>的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle transform</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre>
						<p> <strong class="userinput">
                <code>gradle transform</code>
              </strong>的输出结果<br/>
							Output of
							<strong class="userinput">
								<code>gradle transform</code>
							</strong>
						</p>
						<pre class="screen">&gt; gradle transform
:transform UP-TO-DATE</pre>
					</div>
				</div>
				<br class="example-break">
				<p>现在，Gradle 知道哪些文件要检查以确定任务是否为最新状态。<br/>
					Now, Gradle knows which files to check to determine whether the task is up-to-date or not.
				</p>
				<p>任务的 
          <code class="literal">inputs</code> 属性是 
          <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html" target="_top">
            <code class="classname">TaskInputs</code>
          </a>类型。任务的 
          <code class="literal">outputs</code> 属性是 
          <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html" target="_top">
            <code class="classname">TaskOutputs</code>
          </a>类型。<br/>
					The task's
					<code class="literal">inputs</code>
					property is of type
					<a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html" target="_top">
						<code class="classname">TaskInputs</code>
					</a>
					.
                The task's
					<code class="literal">outputs</code>
					property is of type
					<a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html" target="_top">
						<code class="classname">TaskOutputs</code>
					</a>
					.
				</p>
				<p>一个没有定义输出的任务将
          <span class="emphasis">
            <em>永远不会</em>
          </span>被当作是最新的。对于任务的输出并不是文件的场景，或者是更复杂的场景， 
          <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top">
            <code class="classname">TaskOutputs.upToDateWhen()</code>
          </a>方法允许您以编程方式计算任务的输出是否应该被判断为最新状态。<br/>
					A task with no defined outputs will
					<span class="emphasis">
						<em>never</em>
					</span>
					be considered up-to-date.
                For scenarios where the outputs of a task are not files, or for more complex scenarios, the
					<a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top">
						<code class="classname">TaskOutputs.upToDateWhen()</code>
					</a>
					method allows you to calculate programmatically if
                the tasks outputs should be considered up to date.
				</p>
				<p>一个只定义了输出的任务，如果自上一次构建以来它的输出没有改变，那么它会被判定为最新状态。<br/>
					A task with only outputs defined will be considered up-to-date if those outputs are unchanged since the previous build.
				</p>
			</div>
			<div class="section">
				<div class="titlepage">
					<div>
						<div> <h3 class="title">
                <a name="N10F86"></a>15.9.2. 它是怎么实现的？</h3>
							<h5 class="title">
								<a name="N10F86"></a>
								15.9.2.&nbsp;How does it work?
							</h5>
						</div>
					</div>
				</div>
				<p>在第一次执行任务之前，Gradle
          对输入进行一次快照。这个快照包含了输入文件集和每个文件的内容的哈希值。然后 Gradle
          执行该任务。如果任务成功完成，Gradle
          将对输出进行一次快照。该快照包含输出文件集和每个文件的内容的哈希值。Gradle
          会保存这两个快照，直到任务的下一次执行。<br/>
					Before a task is executed for the first time, Gradle takes a snapshot of the inputs. This snapshot contains
                the set of input files and a hash of the contents of each file. Gradle then executes the task. If the
                task completes successfully, Gradle takes a snapshot of the outputs. This snapshot contains the set of
                output files and a hash of the contents of each file. Gradle persists both snapshots for next time the task
                is executed.
				</p>
				<p>之后每一次，在执行任务之前，Gradle 会对输入和输出进行一次新的快照。如果新的快照和前一次的快照一样，Gradle 会假定这些输出是最新状态的并跳过该任务。如果它们不一则， Gradle 则会执行该任务。Gradle 会保存这两个快照，直到任务的下一次执行。<br/>
					Each time after that, before the task is executed, Gradle takes a new snapshot of the inputs and outputs.
                If the new snapshots are the same as the previous snapshots, Gradle assumes that the outputs are up to
                date and skips the task. If they are not the same, Gradle executes the task. Gradle persists both snapshots
                for next time the task is executed.
				</p>
				<p>请注意，如果一个任务有一个指定的输出目录，在它上一次执行之后添加到该目录的所有文件都将被忽略，并且不会使这个任务成为过时状态。这是不相关的任务可以在不互相干扰的情况下共用一个输出目录。如果你因为一些理由而不想这样，请考虑使用
          <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top">
            <code class="classname">TaskOutputs.upToDateWhen()</code>
          </a>。<br/>
					Note that if a task has an output directory specified, any files added to that directory since the last time it was executed
                are ignored and will NOT cause the task to be out of date. This is so unrelated tasks may share an output directory without interfering with each other.
                If this is not the behaviour you want for some reason, consider using
					<a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top">
						<code class="classname">TaskOutputs.upToDateWhen()</code>
					</a>
				</p>
			</div>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div><h2 class="title">
              <a name="N10F94"></a>15.10. 任务规则</h2>
						<h4 class="title">
							<a name="N10F94"></a>
							15.10.&nbsp;Task rules
						</h4>
					</div>
				</div>
			</div>
			<p>有时你想要有这样一项任务，它的行为依赖于参数数值范围的一个大数或是无限的数字。任务规则是提供此类任务的一个很好的表达方式：<br/>
				Sometimes you want to have a task whose behavior depends on a large or infinite number value range
            of parameters. A very nice and expressive way to provide such tasks are task rules:
			</p>
			<div class="example">
				<a name="taskRule"></a>
				<p class="title">  <b>示例 15.25. 任务规则</b><br/>
					<b>Example&nbsp;15.25.&nbsp;Task rule</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">tasks.addRule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (taskName.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ping"</span>)) {
        task(taskName) &lt;&lt; {
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pinging: "</span> + (taskName - <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ping'</span>)
        }
    }
}</pre>
					<p> <strong class="userinput">
              <code>Gradle q pingServer1</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q pingServer1</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q pingServer1
Pinging: Server1</pre>
				</div>
			</div>
			<br class="example-break">
			<p>这个字符串参数被用作这条规则的描述。当对这个例子运行 
        <strong class="userinput">
          <code>gradle tasks</code>
        </strong> 的时候，这个描述会被显示。<br/>
				The String parameter is used as a description for the rule. This description is shown when running
            for example
				<strong class="userinput">
					<code>gradle tasks</code>
				</strong>
				.
			</p>
			<p>规则不只是从命令行调用任务才起作用。你也可以对基于规则的任务创建依赖关系：<br/>
				Rules not just work when calling tasks from the command line. You can also create dependsOn relations
            on rule based tasks:
			</p>
			<div class="example">
				<a name="taskRuleDependsOn"></a>
				<p class="title"> <b>示例 15.26. 基于规则的任务依赖</b><br/>
					<b>Example&nbsp;15.26.&nbsp;Dependency on rule based tasks</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">tasks.addRule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (taskName.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ping"</span>)) {
        task(taskName) &lt;&lt; {
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pinging: "</span> + (taskName - <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ping'</span>)
        }
    }
}

task groupPing {
    dependsOn pingServer1, pingServer2
}</pre>
					<p>    <strong class="userinput">
              <code>Gradle q groupPing</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q groupPing</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q groupPing
Pinging: Server1
Pinging: Server2</pre>
				</div>
			</div>
			<br class="example-break"></div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div> <h2 class="title">
              <a name="N10FC0"></a>15.11. 析构器任务</h2>
						<h4 class="title">
							<a name="N10FC0"></a>
							15.11.&nbsp;Finalizer tasks
						</h4>
					</div>
				</div>
			</div>
			<div class="note">
				<p>析构器任务是一个 
          <em class="firstterm">孵化中</em> 的功能 (请参阅 
          <a class="xref" href="feature_lifecycle.html#sec:incubating_state">C.1.2 章节， “Incubating”</a>)。<br/>
					Finalizers tasks are an
					<em class="firstterm">incubating</em>
					feature (see
					<a class="xref" href="feature_lifecycle.html#sec:incubating_state">Section&nbsp;C.1.2, &ldquo;Incubating&rdquo;</a>
					).
				</p>
			</div>
			<p>当最终的任务准备运行时，析构器任务会自动地添加到任务图中。<br/>
				Finalizer tasks are automatically added to the task graph when the finalized task is scheduled to run.
			</p>
			<div class="example">
				<a name="taskFinalizers"></a>
				<p class="title"><b>示例 15.27. 添加一个析构器任务</b><br/>
					<b>Example&nbsp;15.27.&nbsp;Adding a task finalizer</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.finalizedBy taskY</pre>
					<p><strong class="userinput">
              <code>gradle -q taskX</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre>
				</div>
			</div>
			<br class="example-break">
			<p>即使最终的任务执行失败，析构器任务也会被执行。<br/>
				Finalizer task will be executed even if the finalized task fails.
			</p>
			<div class="example">
				<a name="taskFinalizersWithFailure"></a>
				<p class="title">     <b>示例 15.28. 执行失败的任务的任务析构器</b><br/>
					<b>Example&nbsp;15.28.&nbsp;Task finalizer for a failing task</b>
				</p>
				<div class="example-contents">
					<p>
						<code class="filename">build.gradle</code>
					</p>
					<pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">throw</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> RuntimeException()
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.finalizedBy taskY</pre>
					<p><strong class="userinput">
              <code>gradle -q taskX</code>
            </strong>的输出结果<br/>
						Output of
						<strong class="userinput">
							<code>gradle -q taskX</code>
						</strong>
					</p>
					<pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre>
				</div>
			</div>
			<br class="example-break">
			<p>另一方面，如果最终的任务什么都不做的话，比如由于失败的任务依赖项或如果它被认为是最新的状态，析构任务不会执行。<br/>
				On the other hand, finalizer tasks are not executed if the finalized task didn't do any work, for example due to failed
            task dependency or if it's considered up to date.
			</p>
			<p>在不管构建成功或是失败，都必须清理创建的资源的情况下，析构认为是很有用的。这样的资源的一个例子是，一个 web 容器会在集成测试任务前开始，并且在之后关闭，即使有些测试失败。<br/>
				Finalizer tasks are useful in situations where build creates a resource that has to be cleaned up regardless
            of the build failing or succeeding. An example of such resource is a web container started before an integration test task
            and which should be always shut down, even if some of the tests fail.
			</p>
			<p>你可以使用
        <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object...)" target="_top">
          <code class="classname">Task.finalizedBy()</code>
        </a>方法指定一个析构器任务。这个方法接受一个任务实例、
        任务名称或<a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object...)" target="_top">
					<code class="classname">Task.dependsOn()</code>所接受的任何其他输入作为参数。
				To specify a finalizer task you use the
				<a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object...)" target="_top">
					<code class="classname">Task.finalizedBy()</code>
				</a>
				method.
            This method accepts a task instance, a task name or any other input accepted by
				<a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object...)" target="_top">
					<code class="classname">Task.dependsOn()</code>
				</a>
				.
			</p>
		</div>
		<div class="section">
			<div class="titlepage">
				<div>
					<div><h2 class="title">
              <a name="sec:the_idea_behind_gradle_tasks"></a>15.12. 总结</h2>
						<h4 class="title">
							<a name="sec:the_idea_behind_gradle_tasks"></a>
							15.12.&nbsp;Summary
						</h4>
					</div>
				</div>
			</div>
			<p>如果你是从 Ant 转过来的，像
        <span class="emphasis">
          <em>Copy</em>
        </span>这种增强的 Gradle 任务，看起来就像是一个 Ant 目标（target）和一个 Ant
        任务（task）之间的混合物。实际上确实是这样子。Gradle 没有像 Ant
        那样对任务和目标进行分离。简单的 Gradle 任务就像 Ant 的目标，而增强的 Gradle 任务还包括
        Ant 任务方面的内容。Gradle 的所有任务共享一个公共
        API，您可以创建它们之间的依赖性。这样的一个任务可能会比一个 Ant
        任务更好配置。它充分利用了类型系统，更具有表现力而且易于维护。<br/>
				If you are coming from Ant, such an enhanced Gradle task as
				<span class="emphasis">
					<em>Copy</em>
				</span>
				looks like a mixture
            between an Ant target and an Ant task. And this is actually the case. The separation that Ant does between
            tasks and targets is not done by Gradle. The simple Gradle tasks are like Ant's targets and the enhanced
            Gradle tasks also include the Ant task aspects. All of Gradle's tasks share a common API and you can create
            dependencies between them. Such a task might be nicer to configure than an Ant task.
            It makes full use of the type system, is more expressive and easier to maintain.
			</p>
		</div>
		<div class="footnotes">
			<br>
			<hr align="left" width="100">
			<div class="footnote">
				<p> <sup>[
          <a href="#N10EFC" name="ftn.N10EFC" class="para">7</a>]</sup>你可能会想，为什么既不导入
          <code class="literal">StopExecutionException</code>也没有通过其完全限定名来访问它。原因是，Gradle
          会向您的脚本添加默认的一些导入。这些导入是可自定义的 （见
          <a class="xref" href="ide_support.html">附录 E，
          <i>现有的 IDE 支持和没有支持时如何应对</i></a>）。<br/> <sup>[
						<a href="#N10EFC" name="ftn.N10EFC" class="para">7</a>
						]</sup> 
					You might be wondering why there is neither an import for the
					<code class="literal">StopExecutionException</code>
					nor do we access it via its fully qualified name. The reason is, that Gradle adds a set of default imports
                    to your script. These imports are customizable (see
					<a class="xref" href="ide_support.html">
						Appendix&nbsp;E,
						<i>Existing IDE Support and how to cope without it</i>
					</a>
					).
				</p>
			</div>
		</div>
	</div>
	<div class="navfooter">
		<div>
			<div class="navbar">
				<a xmlns:xslthl="http://xslthl.sf.net" href="tutorial_this_and_that.html" title="第十四章. 教程 - 杂七杂八">上一章</a>
				<span>|</span>
				<a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
				<span>|</span>
				<a xmlns:xslthl="http://xslthl.sf.net" href="working_with_files.html" title="第十六章. 使用文件">下一章</a>
			</div>
		</div>
	</div>
</body>
</html>