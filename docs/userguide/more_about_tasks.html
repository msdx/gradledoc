<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>More about Tasks - Gradle User Guide Version 2.14.1</title><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css"><link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"><link rel="home" href="userguide.html" title="Gradle User Guide Version 2.14.1"><link rel="up" href="pt03.html" title="Part&nbsp;III.&nbsp;Writing Gradle build scripts"><link rel="prev" href="writing_build_scripts.html" title="Writing Build Scripts - Gradle User Guide Version 2.14.1"><link rel="next" href="working_with_files.html" title="Working With Files - Gradle User Guide Version 2.14.1"></head><body><div class="navheader"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="writing_build_scripts.html" title="Writing Build Scripts - Gradle User Guide Version 2.14.1">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 2.14.1">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="working_with_files.html" title="Working With Files - Gradle User Guide Version 2.14.1">Next</a></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 xmlns:xslthl="http://xslthl.sf.net"><a name="more_about_tasks"></a>Chapter&nbsp;17.&nbsp;More about Tasks</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="more_about_tasks.html#N1110C">17.1. Defining tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11143">17.2. Locating tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:configuring_tasks">17.3. Configuring tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:adding_dependencies_to_tasks">17.4. Adding dependencies to a task</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:ordering_tasks">17.5. Ordering tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N112F7">17.6. Adding a description to a task</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11309">17.7. Replacing tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11326">17.8. Skipping tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:up_to_date_checks">17.9. Skipping tasks that are up-to-date</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N113FA">17.10. Task rules</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#N11431">17.11. Finalizer tasks</a></span></dt><dt><span class="section"><a href="more_about_tasks.html#sec:the_idea_behind_gradle_tasks">17.12. Summary</a></span></dt></dl></div><p>In the introductory tutorial (<a class="xref" href="tutorial_using_tasks.html">Chapter&nbsp;14, <i>Build Script Basics</i></a>) you learned how to
        create simple tasks. You also learned how to add additional behavior to these tasks later on, and you 
        learned how to create dependencies between tasks. This was all about simple tasks, but Gradle takes the concept
        of tasks further. Gradle supports <em class="firstterm">enhanced tasks</em>, which are tasks that have their own
        properties and methods. This is really different from what you are used to with Ant targets. Such enhanced tasks are
        either provided by you or built into Gradle.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N1110C" class="section-anchor" href="#N1110C"></a>17.1.&nbsp;Defining tasks</h2></div></div></div><p>We have already seen how to define tasks using a keyword style in <a class="xref" href="tutorial_using_tasks.html">Chapter&nbsp;14, <i>Build Script Basics</i></a>.
            There are a few variations on this style, which you may need to use in certain situations. For example,
            the keyword style does not work in expressions.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineAsExpression"></a><p class="title"><b>Example&nbsp;17.1.&nbsp;Defining tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task(hello) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

task(copy, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>You can also use strings for the task names:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineUsingStringTaskNames"></a><p class="title"><b>Example&nbsp;17.2.&nbsp;Defining tasks - using strings for task names</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>) &lt;&lt;
{
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

task(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>There is an alternative syntax for defining tasks, which you may prefer to use:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addToTaskContainer"></a><p class="title"><b>Example&nbsp;17.3.&nbsp;Defining tasks with alternative syntax</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.create(name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"hello"</span>
}

tasks.create(name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>Here we add tasks to the <code class="literal">tasks</code> collection. Have a look at
            <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> for more variations of the <code class="literal">create()</code>
            method.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11143" class="section-anchor" href="#N11143"></a>17.2.&nbsp;Locating tasks</h2></div></div></div><p>You often need to locate the tasks that you have defined in the build file, for example, to configure them
            or use them for dependencies. There are a number of ways of doing this. Firstly, each task is available as
            a property of the project, using the task name as the property name:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="accessAsProperty"></a><p class="title"><b>Example&nbsp;17.4.&nbsp;Accessing tasks as properties</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello

println hello.name
println project.hello.name
</pre></div></div><br class="example-break"><p>Tasks are also available through the <code class="literal">tasks</code> collection.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="accessFromTaskContainer"></a><p class="title"><b>Example&nbsp;17.5.&nbsp;Accessing tasks via tasks collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello

println tasks.hello.name
println tasks[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>].name
</pre></div></div><br class="example-break"><p>You can access tasks from any project using the task's path using the <code class="literal">tasks.getByPath()</code>
            method. You can call the <code class="literal">getByPath()</code> method with a task name, or a relative path, or an
            absolute path.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="accessUsingPath"></a><p class="title"><b>Example&nbsp;17.6.&nbsp;Accessing tasks by path</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectA'</span>) {
    task hello
}

task hello

println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectA:hello'</span>).path
println tasks.getByPath(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectA:hello'</span>).path
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
:hello
:hello
:projectA:hello
:projectA:hello</pre></div></div><br class="example-break"><p>Have a look at <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> for more options for locating tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:configuring_tasks" class="section-anchor" href="#sec:configuring_tasks"></a>17.3.&nbsp;Configuring tasks</h2></div></div></div><p>As an example, let's look at the <code class="classname">Copy</code> task provided by Gradle. To create a
            <code class="classname">Copy</code> task for your build, you can declare in your build script:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="declareTask"></a><p class="title"><b>Example&nbsp;17.7.&nbsp;Creating a copy task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myCopy(type: Copy)
</pre></div></div><br class="example-break"><p>This creates a copy task with no default behavior.
            The task can be configured using its API (see <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a>).
			The following examples show several different ways to achieve the same configuration.
        </p><p>Just to be clear, realize that the name of this task is &ldquo;<code class="literal">myCopy</code>&rdquo;, but it is of
        <span class="emphasis"><em>type</em></span> &ldquo;<code class="literal">Copy</code>&rdquo;.  You can have multiple tasks of the same
        <span class="emphasis"><em>type</em></span>, but with different names. You'll find this gives you a lot of power to implement
        cross-cutting concerns across all tasks of a particular type.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configureUsingVar"></a><p class="title"><b>Example&nbsp;17.8.&nbsp;Configuring a task - various ways</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">Copy myCopy = task(myCopy, type: Copy)
myCopy.from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
myCopy.into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
myCopy.include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
</pre></div></div><br class="example-break"><p>This is similar to the way we would configure objects in Java. You have to repeat the context
            (<code class="literal">myCopy</code>) in the configuration statement every time. This is a redundancy and not very
            nice to read.
        </p><p>There is another way of configuring a task. It also preserves the context and it is arguably the
            most readable. It is usually our favorite.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="configureUsingClosure"></a><p class="title"><b>Example&nbsp;17.9.&nbsp;Configuring a task - with closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myCopy(type: Copy)

myCopy {
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"><p>This works for <span class="emphasis"><em>any</em></span> task. Line 3 of the example is just a shortcut for the
            <code class="literal">tasks.getByName()</code> method. It is important to note that if you pass a closure to the
            <code class="literal">getByName()</code> method, this closure is applied to <span class="emphasis"><em>configure</em></span> the task, not when
            the task executes.
        </p><p>You can also use a configuration closure when you define a task.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="defineAndConfigure"></a><p class="title"><b>Example&nbsp;17.10.&nbsp;Defining a task with closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy) {
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"><div class="tip"><h3 class="title">Don't forget about the build phases</h3><p>A task has both configuration and actions.
                When using the <code class="literal">&lt;&lt;</code>, you are simply using a shortcut to define an action.
                Code defined in the configuration section of your task will get executed during the configuration phase of the build regardless of what task was targeted.
                See <a class="xref" href="build_lifecycle.html">Chapter&nbsp;20, <i>The Build Lifecycle</i></a> for more details about the build lifecycle.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:adding_dependencies_to_tasks" class="section-anchor" href="#sec:adding_dependencies_to_tasks"></a>17.4.&nbsp;Adding dependencies to a task</h2></div></div></div><p>There are several ways you can define the dependencies of a task. In
            <a class="xref" href="tutorial_using_tasks.html#sec:task_dependencies">Section&nbsp;14.5, &ldquo;Task dependencies&rdquo;</a>
            you were introduced to defining dependencies using task names. Task names can refer to tasks in the same
            project as the task, or to tasks in other projects. To refer to a task in another project, you prefix the
            name of the task with the path of the project it belongs to. The following is an example which adds a dependency
            from
            <code class="literal">projectA:taskX</code>
            to
            <code class="literal">projectB:taskY</code>:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addDependencyUsingPath"></a><p class="title"><b>Example&nbsp;17.11.&nbsp;Adding dependency on task from another project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectA'</span>) {
    task taskX(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':projectB:taskY'</span>) &lt;&lt; {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
    }
}

project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'projectB'</span>) {
    task taskY &lt;&lt; {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>Instead of using a task name, you can define a dependency using a
            <code class="classname">Task</code> object, as shown in this example:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addDependencyUsingTask"></a><p class="title"><b>Example&nbsp;17.12.&nbsp;Adding dependency using task object</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}

task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.dependsOn taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>For more advanced uses, you can define a task dependency using a closure. When evaluated, the closure is
            passed the task whose dependencies are being calculated. The closure should return a single
            <code class="classname">Task</code> or collection of <code class="classname">Task</code> objects, which are then treated
            as dependencies of the task. The following example adds a dependency from <code class="literal">taskX</code>
            to all the tasks in the project whose name starts with <code class="literal">lib</code>:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="addDependencyUsingClosure"></a><p class="title"><b>Example&nbsp;17.13.&nbsp;Adding dependency using closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}

taskX.dependsOn {
    tasks.findAll { task -&gt; task.name.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>) }
}

task lib1 &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib1'</span>
}

task lib2 &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib2'</span>
}

task notALib &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'notALib'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
lib1
lib2
taskX
</pre></div></div><br class="example-break"><p>For more information about task dependencies, see the <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a> API.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:ordering_tasks" class="section-anchor" href="#sec:ordering_tasks"></a>17.5.&nbsp;Ordering tasks</h2></div></div></div><div class="note"><p>
                Task ordering is an <a class="link" href="feature_lifecycle.html">incubating</a> feature. Please be aware that this feature may change in later Gradle versions.
            </p></div><p>
            In some cases it is useful to control the <span class="emphasis"><em>order</em></span> in which 2 tasks will execute, without introducing an explicit dependency between those tasks.
            The primary difference between a task <span class="emphasis"><em>ordering</em></span> and a task <span class="emphasis"><em>dependency</em></span> is that an ordering rule does not influence which tasks
            will be executed, only the order in which they will be executed.
        </p><p>
            Task ordering can be useful in a number of scenarios:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Enforce sequential ordering of tasks: eg. 'build' never runs before 'clean'.</li><li class="listitem">Run build validations early in the build: eg. validate I have the correct credentials before starting the work for a release build.</li><li class="listitem">Get feedback faster by running quick verification tasks before long verification tasks: eg. unit tests should run before integration tests.</li><li class="listitem">A task that aggregates the results of all tasks of a particular type: eg. test report task combines the outputs of all executed test tasks.</li></ul></div><p>
            There are two ordering rules available: &ldquo;<span class="emphasis"><em>must run after</em></span>&rdquo; and &ldquo;<span class="emphasis"><em>should run after</em></span>&rdquo;.
        </p><p>When you use the &ldquo;must run after&rdquo; ordering rule you specify that <code class="literal">taskB</code> must always
        run after <code class="literal">taskA</code>, whenever both <code class="literal">taskA</code> and <code class="literal">taskB</code> will
        be run. This is expressed as <code class="literal">taskB.mustRunAfter(taskA)</code>. The &ldquo;should run
        after&rdquo; ordering rule is similar but less strict as it will be ignored in two situations. Firstly if using
        that rule introduces an ordering cycle. Secondly when using parallel execution and all dependencies of a
        task have been satisfied apart from the &ldquo;should run after&rdquo; task, then this task will be run regardless of
        whether its &ldquo;should run after&rdquo; dependencies have been run or not. You should use &ldquo;should run after&rdquo;
        where the ordering is helpful but not strictly required.
        </p><p>
            With these rules present it is still possible to execute <code class="literal">taskA</code> without <code class="literal">taskB</code> and vice-versa.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mustRunAfter"></a><p class="title"><b>Example&nbsp;17.14.&nbsp;Adding a 'must run after' task ordering</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
taskY.mustRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskY taskX</code></strong></p><pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre></div></div><br class="example-break"><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="shouldRunAfter"></a><p class="title"><b>Example&nbsp;17.15.&nbsp;Adding a 'should run after' task ordering</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
taskY.shouldRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskY taskX</code></strong></p><pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre></div></div><br class="example-break"><p>In the examples above, it is still possible to execute <code class="literal">taskY</code> without causing <code class="literal">taskX</code> to run:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="mustRunAfterSingleTask"></a><p class="title"><b>Example&nbsp;17.16.&nbsp;Task ordering does not imply task execution</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q taskY</code></strong></p><pre class="screen">&gt; gradle -q taskY
taskY</pre></div></div><br class="example-break"><p>To specify a &ldquo;must run after&rdquo; or &ldquo;should run after&rdquo; ordering between 2 tasks, you use the <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object[])" target="_top"><code class="classname">Task.mustRunAfter(java.lang.Object[])</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/Task.html#shouldRunAfter(java.lang.Object[])" target="_top"><code class="classname">Task.shouldRunAfter(java.lang.Object[])</code></a> methods.
            These methods accept a task instance, a task name or any other input accepted by <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])" target="_top"><code class="classname">Task.dependsOn(java.lang.Object[])</code></a>.
        </p><p>
            Note that &ldquo;<code class="literal">B.mustRunAfter(A)</code>&rdquo; or &ldquo;<code class="literal">B.shouldRunAfter(A)</code>&rdquo; does not imply any execution dependency between the tasks:
        </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">It is possible to execute tasks <code class="literal">A</code> and <code class="literal">B</code> independently. The ordering rule only has an effect when both tasks are scheduled for execution.</li><li class="listitem">When run with <code class="literal">--continue</code>, it is possible for <code class="literal">B</code> to execute in the event that <code class="literal">A</code> fails.</li></ul></div><p>As mentioned before, the &ldquo;should run after&rdquo; ordering rule will be ignored if it introduces an ordering cycle:</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="shouldRunAfterWithCycle"></a><p class="title"><b>Example&nbsp;17.17.&nbsp;A 'should run after' task ordering is ignored if it introduces an ordering cycle</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}
task taskZ &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskZ'</span>
}
taskX.dependsOn taskY
taskY.dependsOn taskZ
taskZ.shouldRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskZ
taskY
taskX</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N112F7" class="section-anchor" href="#N112F7"></a>17.6.&nbsp;Adding a description to a task</h2></div></div></div><p>You can add a description to your task. This description is displayed when executing
            <strong class="userinput"><code>gradle tasks</code></strong>.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="describeTask"></a><p class="title"><b>Example&nbsp;17.18.&nbsp;Adding a description to a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy) {
   description <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'Copies the resource directory to the target directory.'</span>
   from <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'resources'</span>
   into <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'target'</span>
   include(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.txt'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.xml'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11309" class="section-anchor" href="#N11309"></a>17.7.&nbsp;Replacing tasks</h2></div></div></div><p>Sometimes you want to replace a task. For example, if you want to exchange a task added by the Java plugin
            with a custom task of a different type. You can achieve this with:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="replaceTask"></a><p class="title"><b>Example&nbsp;17.19.&nbsp;Overwriting a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy)

task copy(overwrite: true) &lt;&lt; {
    println(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'I am the new one.'</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p><pre class="screen">&gt; gradle -q copy
I am the new one.
</pre></div></div><br class="example-break"><p>This will replace a task of type <code class="literal">Copy</code> with the task you've defined, because it
        uses the same name. When you define the new task, you have to set the <code class="literal">overwrite</code> property
        to true. Otherwise Gradle throws an exception, saying that a task with that name already exists.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11326" class="section-anchor" href="#N11326"></a>17.8.&nbsp;Skipping tasks</h2></div></div></div><p>Gradle offers multiple ways to skip the execution of a task.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N1132B" class="section-anchor" href="#N1132B"></a>17.8.1.&nbsp;Using a predicate</h3></div></div></div><p>You can use the <code class="literal">onlyIf()</code> method to attach a predicate to a task. The task's
                actions are only executed if the predicate evaluates to true. You implement the predicate as a closure.
                The closure is passed the task as a parameter, and should return true if the task should execute
                and false if the task should be skipped. The predicate is evaluated just before the task is due
                to be executed.
                </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskOnlyIf"></a><p class="title"><b>Example&nbsp;17.20.&nbsp;Skipping a task using a predicate</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hello world'</span>
}

hello.onlyIf { !project.hasProperty(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'skipHello'</span>) }
</pre><p>Output of <strong class="userinput"><code>gradle hello -PskipHello</code></strong></p><pre class="screen">&gt; gradle hello -PskipHello
:hello SKIPPED

BUILD SUCCESSFUL

Total time: 1 secs
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11343" class="section-anchor" href="#N11343"></a>17.8.2.&nbsp;Using StopExecutionException</h3></div></div></div><p>If the logic for skipping a task can't be expressed with a predicate, you can use the
            <a class="ulink" href="../javadoc/org/gradle/api/tasks/StopExecutionException.html" target="_top"><code class="classname">StopExecutionException</code></a>. If this exception is thrown by an action,
            the further execution of this action as well as the execution of
            any following action of this task is skipped. The build continues with executing the next task.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="stopExecutionException"></a><p class="title"><b>Example&nbsp;17.21.&nbsp;Skipping tasks with StopExecutionException</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task compile &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'We are doing the compile.'</span>
}

compile.doFirst {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Here you would put arbitrary conditions in real life.</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// But this is used in an integration test so we want defined behavior.</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (true) { <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">throw</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> StopExecutionException() }
}
task myTask(dependsOn: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>) &lt;&lt; {
   println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'I am not affected'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q myTask</code></strong></p><pre class="screen">&gt; gradle -q myTask
I am not affected
</pre></div></div><br class="example-break"><p>This feature is helpful if you work with tasks provided by Gradle. It allows you to add
            <span class="emphasis"><em>conditional</em></span> execution of the built-in actions of such a task.
            <sup>[<a href="#ftn.N11362" name="N11362" class="footnote">7</a>]</sup>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N1136C" class="section-anchor" href="#N1136C"></a>17.8.3.&nbsp;Enabling and disabling tasks</h3></div></div></div><p>Every task has an <code class="literal">enabled</code>
            flag which defaults to <code class="literal">true</code>. Setting it to <code class="literal">false</code> prevents the
            execution of any of the task's actions.
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="disableTask"></a><p class="title"><b>Example&nbsp;17.22.&nbsp;Enabling and disabling tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task disableMe &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'This should not be printed if the task is disabled.'</span>
}
disableMe.enabled = false
</pre><p>Output of <strong class="userinput"><code>gradle disableMe</code></strong></p><pre class="screen">&gt; gradle disableMe
:disableMe SKIPPED

BUILD SUCCESSFUL

Total time: 1 secs
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:up_to_date_checks" class="section-anchor" href="#sec:up_to_date_checks"></a>17.9.&nbsp;Skipping tasks that are up-to-date</h2></div></div></div><p>If you are using one of the tasks that come with Gradle, such as a task added by the Java plugin,
            you might have noticed that Gradle will skip tasks that are up-to-date. This behaviour is also available
            for your tasks, not just for built-in tasks.
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:task_inputs_outputs" class="section-anchor" href="#sec:task_inputs_outputs"></a>17.9.1.&nbsp;Declaring a task's inputs and outputs</h3></div></div></div><p>
                Let's have a look at an example. Here our task generates several output files from a source XML file. Let's
                run it a couple of times.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="generatorTask"></a><p class="title"><b>Example&nbsp;17.23.&nbsp;A generator task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task transform {
    ext.srcFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'mountains.xml'</span>)
    ext.destDir = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(buildDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'generated'</span>)
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Transforming source file."</span>
        destDir.mkdirs()
        def mountains = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> XmlParser().parse(srcFile)
        mountains.mountain.each { mountain -&gt;
            def name = mountain.name[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def height = mountain.height[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def destFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(destDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${name}.txt"</span>)
            destFile.text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$name -&gt; ${height}\n"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre></div></div><br class="example-break"><p>Notice that Gradle executes this task a second time, and does not skip the task even though nothing has
                changed. Our example task was defined using an action closure. Gradle has no idea what the closure does and
                cannot automatically figure out whether the task is up-to-date or not. To use Gradle's up-to-date checking,
                you need to declare the inputs and outputs of the task.
            </p><p>Each task has an <code class="literal">inputs</code> and <code class="literal">outputs</code> property, which you use to
                declare the inputs and outputs of the task. Below, we have changed our example to declare that it takes
                the source XML file as an input and produces output to a destination directory. Let's run it a couple
                of times.
            </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="incrementalTask"></a><p class="title"><b>Example&nbsp;17.24.&nbsp;Declaring the inputs and outputs of a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task transform {
    ext.srcFile = file(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'mountains.xml'</span>)
    ext.destDir = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(buildDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'generated'</span>)
    inputs.file srcFile
    outputs.dir destDir
    doLast {
        println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Transforming source file."</span>
        destDir.mkdirs()
        def mountains = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> XmlParser().parse(srcFile)
        mountains.mountain.each { mountain -&gt;
            def name = mountain.name[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def height = mountain.height[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">0</span>].text()
            def destFile = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> File(destDir, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"${name}.txt"</span>)
            destFile.text = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$name -&gt; ${height}\n"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform
Transforming source file.</pre><p>Output of <strong class="userinput"><code>gradle transform</code></strong></p><pre class="screen">&gt; gradle transform
:transform UP-TO-DATE
</pre></div></div><br class="example-break"><p>Now, Gradle knows which files to check to determine whether the task is up-to-date or not.</p><p>
                The task's <code class="literal">inputs</code> property is of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html" target="_top"><code class="classname">TaskInputs</code></a>.
                The task's <code class="literal">outputs</code> property is of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html" target="_top"><code class="classname">TaskOutputs</code></a>.
            </p><p>
                A task with no defined outputs will <span class="emphasis"><em>never</em></span> be considered up-to-date.
                For scenarios where the outputs of a task are not files, or for more complex scenarios, the
                <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top"><code class="classname">TaskOutputs.upToDateWhen(groovy.lang.Closure)</code></a> method allows you to calculate programmatically if
                the tasks outputs should be considered up to date.
            </p><p>
                A task with only outputs defined will be considered up-to-date if those outputs are unchanged since the previous build.
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N113EC" class="section-anchor" href="#N113EC"></a>17.9.2.&nbsp;How does it work?</h3></div></div></div><p>
                Before a task is executed for the first time, Gradle takes a snapshot of the inputs. This snapshot contains
                the set of input files and a hash of the contents of each file. Gradle then executes the task. If the
                task completes successfully, Gradle takes a snapshot of the outputs. This snapshot contains the set of
                output files and a hash of the contents of each file. Gradle persists both snapshots for the next time the task
                is executed.
            </p><p>
                Each time after that, before the task is executed, Gradle takes a new snapshot of the inputs and outputs.
                If the new snapshots are the same as the previous snapshots, Gradle assumes that the outputs are up to
                date and skips the task. If they are not the same, Gradle executes the task. Gradle persists both snapshots
                for the next time the task is executed.
            </p><p>
                Note that if a task has an output directory specified, any files added to that directory since the last time it was executed
                are ignored and will NOT cause the task to be out of date. This is so unrelated tasks may share an output directory without interfering with each other.
                If this is not the behaviour you want for some reason, consider using <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen(groovy.lang.Closure)" target="_top"><code class="classname">TaskOutputs.upToDateWhen(groovy.lang.Closure)</code></a>
            </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N113FA" class="section-anchor" href="#N113FA"></a>17.10.&nbsp;Task rules</h2></div></div></div><p>Sometimes you want to have a task whose behavior depends on a large or infinite number value range
            of parameters. A very nice and expressive way to provide such tasks are task rules:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskRule"></a><p class="title"><b>Example&nbsp;17.25.&nbsp;Task rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.addRule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (taskName.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ping"</span>)) {
        task(taskName) &lt;&lt; {
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pinging: "</span> + (taskName - <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ping'</span>)
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q pingServer1</code></strong></p><pre class="screen">&gt; gradle -q pingServer1
Pinging: Server1
</pre></div></div><br class="example-break"><p>The String parameter is used as a description for the rule, which is shown with <strong class="userinput"><code>gradle tasks</code></strong>.
        </p><p>Rules are not only used when calling tasks from the command line. You can also create dependsOn relations
            on rule based tasks:
        </p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskRuleDependsOn"></a><p class="title"><b>Example&nbsp;17.26.&nbsp;Dependency on rule based tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.addRule(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (taskName.startsWith(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ping"</span>)) {
        task(taskName) &lt;&lt; {
            println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"Pinging: "</span> + (taskName - <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ping'</span>)
        }
    }
}

task groupPing {
    dependsOn pingServer1, pingServer2
}
</pre><p>Output of <strong class="userinput"><code>gradle -q groupPing</code></strong></p><pre class="screen">&gt; gradle -q groupPing
Pinging: Server1
Pinging: Server2
</pre></div></div><br class="example-break"><p>If you run &ldquo;<code class="literal">gradle -q tasks</code>&rdquo; you won't find a task named
        &ldquo;<code class="literal">pingServer1</code>&rdquo; or &ldquo;<code class="literal">pingServer2</code>&rdquo;, but this script is executing logic
        based on the request to run those tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="N11431" class="section-anchor" href="#N11431"></a>17.11.&nbsp;Finalizer tasks</h2></div></div></div><div class="note"><p>
                Finalizers tasks are an <em class="firstterm">incubating</em> feature (see <a class="xref" href="feature_lifecycle.html#sec:incubating_state">Section&nbsp;C.1.2, &ldquo;Incubating&rdquo;</a>).
            </p></div><p>Finalizer tasks are automatically added to the task graph when the finalized task is scheduled to run.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskFinalizers"></a><p class="title"><b>Example&nbsp;17.27.&nbsp;Adding a task finalizer</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.finalizedBy taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre></div></div><br class="example-break"><p>Finalizer tasks will be executed even if the finalized task fails.</p><div class="example"><a xmlns:xslthl="http://xslthl.sf.net" name="taskFinalizersWithFailure"></a><p class="title"><b>Example&nbsp;17.28.&nbsp;Task finalizer for a failing task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskX'</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">throw</span> <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">new</span> RuntimeException()
}
task taskY &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'taskY'</span>
}

taskX.finalizedBy taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre></div></div><br class="example-break"><p>On the other hand, finalizer tasks are not executed if the finalized task didn't do any work, for example if it
        is considered up to date or if a dependent task fails.</p><p>Finalizer tasks are useful in situations where the build creates a resource that has to be cleaned up regardless
            of the build failing or succeeding. An example of such a resource is a web container that is started before an integration test task
            and which should be always shut down, even if some of the tests fail.</p><p>To specify a finalizer task you use the <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object[])" target="_top"><code class="classname">Task.finalizedBy(java.lang.Object[])</code></a> method.
            This method accepts a task instance, a task name, or any other input accepted by <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])" target="_top"><code class="classname">Task.dependsOn(java.lang.Object[])</code></a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:the_idea_behind_gradle_tasks" class="section-anchor" href="#sec:the_idea_behind_gradle_tasks"></a>17.12.&nbsp;Summary</h2></div></div></div><p>If you are coming from Ant, an enhanced Gradle task like <span class="emphasis"><em>Copy</em></span> seems like a cross
            between an Ant target and an Ant task. Although Ant's tasks and targets are really different entities,
            Gradle combines these notions into a single entity. Simple Gradle tasks are like Ant's targets, but enhanced
            Gradle tasks also include aspects of Ant tasks. All of Gradle's tasks share a common API and you can create
            dependencies between them. These tasks are much easier to configure than an Ant task.
            They make full use of the type system, and are more expressive and easier to maintain.
        </p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N11362" name="ftn.N11362" class="para">7</a>] </sup>You might be wondering why there is neither an import for the
                    <code class="literal">StopExecutionException</code>
                    nor do we access it via its fully qualified name. The reason is, that Gradle adds a set of default imports
                    to your script (see <a class="xref" href="writing_build_scripts.html#script-default-imports">Section&nbsp;16.8, &ldquo;Default imports&rdquo;</a>).
                </p></div></div></div><div class="navfooter"><div><div class="navbar"><a xmlns:xslthl="http://xslthl.sf.net" href="writing_build_scripts.html" title="Writing Build Scripts - Gradle User Guide Version 2.14.1">Previous</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle User Guide Version 2.14.1">Contents</a><span>|</span><a xmlns:xslthl="http://xslthl.sf.net" href="working_with_files.html" title="Working With Files - Gradle User Guide Version 2.14.1">Next</a></div></div></div></body></html>