<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>概述——Gradle 用户指南 2.14.1版 - Overview - Gradle User Guide Version 2.14.1</title>
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css">
  <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
  <link rel="home" href="userguide.html" title="Gradle 用户指南 2.14.1版">
  <link rel="up" href="pt01.html" title="第一部分. 关于 Gradle">
  <link rel="prev" href="introduction.html" title="简介——Gradle 用户指南 2.14.1版">
  <link rel="next" href="pt02.html" title="第二部分. 使用现有构建">
 </head>
 <body>
  <div class="navheader">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="introduction.html" title="简介——Gradle 用户指南 2.14.1版">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南 2.14.1版">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="pt02.html" title="第二部分. 使用现有构建">下一章</a>
    </div>
   </div>
  </div>
  <div class="chapter">
   <div class="titlepage">
    <div>
     <div>
      <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="overview"></a>第二章. 概述</h1>
      <h3 xmlns:xslthl="http://xslthl.sf.net"><a name="overview"></a>Chapter&nbsp;2.&nbsp;Overview</h3>
     </div>
    </div>
   </div>
   <div class="toc">
    <p><b>目录</b><br><b>Table of Contents</b></p>
    <dl>
     <dt>
      <span class="section"><a href="overview.html#sec:special_feature_of_gradle">2.1. 特性 - Features</a></span>
     </dt>
     <dt>
      <span class="section"><a href="overview.html#sec:why_groovy">2.2. 为什么选择 Groovy? - Why Groovy?</a></span>
     </dt>
    </dl>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:special_feature_of_gradle" class="section-anchor" href="#sec:special_feature_of_gradle"></a>2.1. 特性</h2>
       <h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:special_feature_of_gradle" class="section-anchor" href="#sec:special_feature_of_gradle"></a>2.1.&nbsp;Features</h4>
      </div>
     </div>
    </div>
    <p>以下是 Gradle 的一些特性列表。 <br>Here is a list of some of Gradle's features.</p>
    <div class="variablelist">
     <dl>
      <dt>
       <span class="term">声明式构建和基于约定的构建<br>Declarative builds and build-by-convention</span>
      </dt>
      <dd>
       <p>Gradle 的核心是基于Groovy的丰富可扩展的域特定语言（DSL）。Gradle通过提供可以根据需要进行组合的声明性语言元素，将声明性构建提升到一个新的层次。这些元素还将为Java，Groovy，OSGi，Web和Scala项目提供基于约定的构建。更重要的是，这种声明性语言是可扩展的。可以通过添加你自己的新语言元素，或者是增加现有的元素，从而提供简洁，可维护以及易于理解的构建。 <br>At the heart of Gradle lies a rich extensible Domain Specific Language (DSL) based on Groovy. Gradle pushes declarative builds to the next level by providing declarative language elements that you can assemble as you like. Those elements also provide build-by-convention support for Java, Groovy, OSGi, Web and Scala projects. Even more, this declarative language is extensible. Add your own new language elements or enhance the existing ones, thus providing concise, maintainable and comprehensible builds.</p>
      </dd>
      <dt>
       <span class="term">基于依赖的编程语言<br>Language for dependency based programming</span>
      </dt>
      <dd>
       <p>声明性语言位于通用任务图之上，你可以在构建中充分利用它。它提供了极大的灵活性，使 Gradle 能适应你的独特需求。 <br>The declarative language lies on top of a general purpose task graph, which you can fully leverage in your builds. It provides utmost flexibility to adapt Gradle to your unique needs.</p>
      </dd>
      <dt>
       <span class="term">构建结构化<br>Structure your build</span>
      </dt>
      <dd>
       <p>Gradle的灵活性和丰富性最终允许你将通用的设计原则应用于你的构建。 例如，很容易通过可重用的构建逻辑来组织构建。把不必要而没有直接联系的内容内联在一起是不适合的。不要强制拆分原本一起的东西（例如在你的项目层次结构中）。避免出现分散式的变化而使你的建设的维护变成噩梦。最后，你可以创建一个结构良好、易于维护、易于理解的构建。<br>The suppleness and richness of Gradle finally allows you to apply common design principles to your build. For example, it is very easy to compose your build from reusable pieces of build logic. Inline stuff where unnecessary indirections would be inappropriate. Don't be forced to tear apart what belongs together (e.g. in your project hierarchy). Avoid smells like shotgun changes or divergent change that turn your build into a maintenance nightmare. At last you can create a well structured, easily maintained, comprehensible build.</p>
      </dd>
      <dt>
       <span class="term">深度 API<br>Deep API</span>
      </dt>
      <dd>
       <p>Gradle 从希望被嵌入使用，到在整个构建执行的生命周期中有许多钩子，它都允许你监视和自定义它的配置和及核心的执行行为。 <br>From being a pleasure to be used embedded to its many hooks over the whole lifecycle of build execution, Gradle allows you to monitor and customize its configuration and execution behavior to its very core.</p>
      </dd>
      <dt>
       <span class="term">Gradle 伸缩性<br>Gradle scales</span>
      </dt>
      <dd>
       <p>Gradle 的扩展性非常好。从简单的单项目构建，到大型的企业多项目构建，它都能大大地提高你的生产力。这是结构化构建来说也是对的。凭借最先进的增量构建功能，对于解决许多大型企业构建所遭遇的性能难题也是如此。 <br>Gradle scales very well. It significantly increases your productivity, from simple single project builds up to huge enterprise multi-project builds. This is true for structuring the build. With the state-of-art incremental build function, this is also true for tackling the performance pain many large enterprise builds suffer from.</p>
      </dd>
      <dt>
       <span class="term">多项目构建<br>Multi-project builds</span>
      </dt>
      <dd>
       <p>Gradle对多项目构建的支持非常出色。项目依赖是第一公民。我们允许你在一个多项目构建中为项目关系进行建模，因为它们真的适用于你的问题域。Gradle遵循你的布局，而不是布局遵循Gradle。 <br>Gradle's support for multi-project build is outstanding. Project dependencies are first class citizens. We allow you to model the project relationships in a multi-project build as they really are for your problem domain. Gradle follows your layout not vice versa.</p>
       <p>Gradle提供了部分构建。如果你是在构建一个子项目，Gradle将负责构建这个子项目所依赖的所有子项目。你也可以选择重新构建依赖于特定子项目的所有子项目。这和增量构建一起为大型构建省下了大量的时间。 <br>Gradle provides partial builds. If you build a single subproject Gradle takes care of building all the subprojects that subproject depends on. You can also choose to rebuild the subprojects that depend on a particular subproject. Together with incremental builds this is a big time saver for larger builds.</p>
      </dd>
      <dt>
       <span class="term">多种方式去管理依赖<br>Many ways to manage your dependencies</span>
      </dt>
      <dd>
       <p>不同的团队喜欢使用不同的方式来管理他们的外部依赖。从远程Maven和Ivy仓库的传递依赖管理到本地文件系统上的jar包或目录，Gradle为所有策略都提供了方便的支持。<br>Different teams prefer different ways to manage their external dependencies. Gradle provides convenient support for any strategy. From transitive dependency management with remote Maven and Ivy repositories to jars or directories on the local file system.</p>
      </dd>
      <dt>
       <span class="term">Gradle 是第一个构建集成工具<br>Gradle is the first build integration tool</span>
      </dt>
      <dd>
       <p>Ant 任务是一级公民。更有趣的是，Ant 项目也是一级公民。Gradle 为 Ant 项目提供深度的导入，能够在运行时将 Ant 目标转换为原生的 Gradle 任务。你可以从 Gradle 中依赖它们，增强它们，甚至在你的 build.xml 中定义对 Gradle 任务的依赖。同时，Gradle 还为属性，路径等提供了同样的集成。<br>Ant tasks are first class citizens. Even more interesting, Ant projects are first class citizens as well. Gradle provides a deep import for any Ant project, turning Ant targets into native Gradle tasks at runtime. You can depend on them from Gradle, you can enhance them from Gradle, you can even declare dependencies on Gradle tasks in your build.xml. The same integration is provided for properties, paths, etc ...</p>
       <p>Gradle完全支持你现有的用于发布和检索依赖的 Maven 或 Ivy 仓库基础架构。并且 Gradle 也提供了一个转换器，用于将一个 Maven 的<code class="filename">pom.xml</code>转换为一个 Gradle 脚本。Maven 项目的运行时导入也即将推出。<br>Gradle fully supports your existing Maven or Ivy repository infrastructure for publishing and retrieving dependencies. Gradle also provides a converter for turning a Maven <code class="filename">pom.xml</code> into a Gradle script. Runtime imports of Maven projects will come soon.</p>
      </dd>
      <dt>
       <span class="term">易于迁移<br>Ease of migration</span>
      </dt>
      <dd>
       <p>Gradle 可以适应你任何结构的项目。因此你可以在生产构建所在的分支上随时开发你的Gradle构建，并且它们可以并行演进。我们通常建议编写测试用例，以确保生成的工件相似。这样，迁移的破坏性尽可能小，并且尽可能可靠。这是遵循小步重构的最佳实践。 <br>Gradle can adapt to any structure you have. Therefore you can always develop your Gradle build in the same branch where your production build lives and both can evolve in parallel. We usually recommend to write tests that make sure that the produced artifacts are similar. That way migration is as less disruptive and as reliable as possible. This is following the best-practices for refactoring by applying baby steps.</p>
      </dd>
      <dt>
       <span class="term">Groovy</span>
      </dt>
      <dd>
       <p>Gradle 的构建脚本是使用 Groovy 来编写的，而不是 XML。但是与其他方法不同，这不只是简单地展示动态语言的原始脚本能力，那样只会导致构建难以维护。Gradle的整个设计是面向作为一门语言使用的，而不是作为一个僵化的框架。并且 Groovy 是我们的粘合剂，可以使你通过使用Gradle（或你）所提供的抽象概念，来讲述你的个人故事。Gradle 提供了一些标准的故事，但它们没有任何特权。与其他的声明式构建系统相比，这对于我们来说是一个主要的区别特征。我们的 Groovy 支持也不只是简单的糖衣，整个的 Gradle API 都是完全的 Groovy 化的。添加 Groovy 会带来乐趣而富有成效的体验。 <br>Gradle's build scripts are written in Groovy, not XML. But unlike other approaches this is not for simply exposing the raw scripting power of a dynamic language. That would just lead to a very difficult to maintain build. The whole design of Gradle is oriented towards being used as a language, not as a rigid framework. And Groovy is our glue that allows you to tell your individual story with the abstractions Gradle (or you) provide. Gradle provides some standard stories but they are not privileged in any form. This is for us a major distinguishing feature compared to other declarative build systems. Our Groovy support is not just sugar coating. The whole Gradle API is fully Groovy-ized. Adding Groovy results in an enjoyable and productive experience.</p>
      </dd>
      <dt>
       <span class="term">Gradle 包装器<br>The Gradle wrapper</span>
      </dt>
      <dd>
       <p>Gradle 包装器允许你能够在没有安装 Gradle 的机器上执行 Gradle 构建。这对于一些持续集成服务器来说是很有用的。对于开源项目来说，也利于保持构建它的低门槛。包装器对于企业来说也同样友好。对于客户端机器来说，它是一种零管理方法。它还强制使用特定的 Gradle 版本，从而最大限度地减少支持问题。 <br>The Gradle Wrapper allows you to execute Gradle builds on machines where Gradle is not installed. This is useful for example for some continuous integration servers. It is also useful for an open source project to keep the barrier low for building it. The wrapper is also very interesting for the enterprise. It is a zero administration approach for the client machines. It also enforces the usage of a particular Gradle version thus minimizing support issues.</p>
      </dd>
      <dt>
       <span class="term">免费和开源<br>Free and open source</span>
      </dt>
      <dd>
       <p>Gradle 是一个开源项目，并且使用 <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a> 开源协议。 <br>Gradle is an open source project, and is licensed under the <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a>.</p>
      </dd>
     </dl>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:why_groovy" class="section-anchor" href="#sec:why_groovy"></a>2.2. 为什么选择 Groovy？</h2>
       <h4 class="title"><a xmlns:xslthl="http://xslthl.sf.net" name="sec:why_groovy" class="section-anchor" href="#sec:why_groovy"></a>2.2.&nbsp;Why Groovy?</h4>
      </div>
     </div>
    </div>
    <p>我们认为在用于 <span class="emphasis"><em>构建脚本</em></span>这种情况中，比起使用 XML，（基于一种动态语言的）内部 DSL 会有很大的优势。那么，有好几种动态语言，我们为什么要使用 Groovy？答案在于 Gradle 的操作环境。尽管 Gradle 的核心是成为一个通用的构建工具，但是它的主要重点还是 Java 项目。在这样的项目中，团队成员都知道 Java。我们认为 ，构建应尽可能对 <span class="emphasis"><em>所有</em></span> 团队成员透明。 <br>We think the advantages of an internal DSL (based on a dynamic language) over XML are tremendous when used in <span class="emphasis"><em>build scripts</em></span>. There are a couple of dynamic languages out there. Why Groovy? The answer lies in the context Gradle is operating in. Although Gradle is a general purpose build tool at its core, its main focus are Java projects. In such projects the team members will be very familiar with Java. We think a build should be as transparent as possible to <span class="emphasis"><em>all</em></span> team members.</p>
    <p>在这种情况下，你可能会想问，为什么我们不使用 Java 来作为构建脚本的语言。这确实是一个很好的问题。对你的团队而言，它的透明度最高，并且学习曲线最低，但由于 Java 的局限性，这样的一门构建语言就不会像它所应该的那样好、富有表现力和强大。<sup>[<a href="#ftn.N100C4" name="N100C4" class="footnote">1</a>]</sup> 像 Python，Groovy 或是 Ruby 这样的语言能够比它更好。我们之所以选择 Groovy，是因为它为 Java 程序员提供了最大的透明度。它的基本语法，类型系统，包结构等都与 Java 相同。Groovy 具有 Java 的共同基础，只是在其之上提供了更多功能。 <br>In that case, you might argue why we don't just use Java as the language for build scripts. We think this is a valid question. It would have the highest transparency for your team and the lowest learning curve, but because of the limitations of Java, such a build language would not be as nice, expressive and powerful as it could be. <sup>[<a href="#ftn.N100C4" name="N100C4" class="footnote">1</a>]</sup> Languages like Python, Groovy or Ruby do a much better job here. We have chosen Groovy as it offers by far the greatest transparency for Java people. Its base syntax is the same as Java's as well as its type system, its package structure and other things. Groovy provides much more on top of that, but with the common foundation of Java.</p>
    <p>对于具有 Python 或 Ruby 知识或渴望学习它们的 Java 开发人员来说，上述的论点并不适用。Gradle 设计非常适全于在 JRuby 或 Jython 中创建另一种构建脚本引擎。它只是目前对我们来说不是最高优先级。我们很乐意支持任何社区来努力创建其他的构建脚本引擎。 <br>For Java developers with Python or Ruby knowledge or the desire to learn them, the above arguments don't apply. The Gradle design is well-suited for creating another build script engine in JRuby or Jython. It just doesn't have the highest priority for us at the moment. We happily support any community effort to create additional build script engines.</p>
   </div>
   <div class="footnotes">
    <br>
    <hr align="left" width="100">
    <div class="footnote">
     <p><sup>[<a href="#N100C4" name="ftn.N100C4" class="para">1</a>] </sup>在 <a class="ulink" href="http://www.defmacro.org/ramblings/lisp.html" target="_top">http://www.defmacro.org/ramblings/lisp.html</a> 上面，你可以找到一篇比较 Ant，XML，Java 和 List 的文章。很有趣的是，这篇文章中的“ 如果Java 具有该语法”的语法实际上正是 Groovy 语法。 <br><sup>[<a href="#N100C4" name="ftn.N100C4" class="para">1</a>] </sup>At <a class="ulink" href="http://www.defmacro.org/ramblings/lisp.html" target="_top">http://www.defmacro.org/ramblings/lisp.html</a> you find an interesting article comparing Ant, XML, Java and Lisp. It's funny that the 'if Java had that syntax' syntax in this article is actually the Groovy syntax.</p>
    </div>
   </div>
  </div>
  <div class="navfooter">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="introduction.html" title="简介——Gradle 用户指南 2.14.1版">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南 2.14.1版">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="pt02.html" title="第二部分. 使用现有构建">下一章</a>
    </div>
   </div>
  </div>
 </body>
</html>