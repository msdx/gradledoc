<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>第五十章. 依赖管理 - Chapter&nbsp;50.&nbsp;Dependency Management</title>
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css">
  <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
  <link rel="home" href="userguide.html" title="Gradle 用户指南">
  <link rel="up" href="userguide.html" title="Gradle 用户指南">
  <link rel="prev" href="buildDashboard_plugin.html" title="第四十九章. Build Dashboard 插件">
  <link rel="next" href="artifact_management.html" title="第五十一章. 发布构件">
 <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-4684296714025694",
          enable_page_level_ads: true
     });
</script>
</head>
 <body>
<div style="position:fixed; bottom:0; right:10; width:250px; ">
<script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- gradle广告 -->
<ins class="adsbygoogle" style="display:inline-block;width:250px;height:250px" data-ad-client="ca-pub-4684296714025694" data-ad-slot="5882227979" data-ad-format="auto" data-full-width-responsive="true"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
  <div class="navheader">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="buildDashboard_plugin.html" title="第四十九章. Build Dashboard 插件">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="artifact_management.html" title="第五十一章. 发布构件">下一章</a>
    </div>
   </div>
  </div>
  <div class="chapter">
   <div class="titlepage">
    <div>
     <div>
      <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="dependency_management"></a>第五十章. 依赖管理</h1>
      <h3 xmlns:xslthl="http://xslthl.sf.net"><a name="dependency_management"></a>Chapter&nbsp;50.&nbsp;Dependency Management</h3>
     </div>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:Introduction"></a>50.1. 介绍</h2>
       <h4 class="title"><a name="sec:Introduction"></a>50.1.&nbsp;Introduction</h4>
      </div>
     </div>
    </div>
    <p>依赖管理是每个构建的关键特性，并且 Gradle 强调提供最好的依赖管理，容易理解以及使用各种各样的方法来兼容。如果您熟悉使用 Maven 或 Ivy 的方法，那么你会很高兴地知道，Gradle 完全兼容这两种方法，除此之外，它还有足够的灵活性，以支持完全自定义的方法。 <br>Dependency management is a critical feature of every build, and Gradle has placed an emphasis on offering first-class dependency management that is both easy-to-understand and compatible with a wide variety of approaches. If you are familiar with the approach used by either Maven or Ivy you will be delighted to learn that Gradle is fully compatible with both approaches in addition to being flexible enough to support fully-customized approaches.</p>
    <p>这里是 Gradle 支持的依赖管理的主要亮点:<br>Here are the major highlights of Gradle's support for dependency management:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p><span class="emphasis"><em>依赖管理传递</em></span>： Gradle 赋予你对你的项目依赖项树的完全控制。 </p><br><p><span class="emphasis"><em>Transitive dependency management</em></span>: Gradle gives you full control of your project's dependency tree. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>对非管理依赖的支持</em></span>：如果你的依赖只是版本控制下或共享的驱动器中的文件，Gradle 也提供了强大的功能以支持这种情况。 </p><br><p><span class="emphasis"><em>Support for non-managed dependencies</em></span>: If your dependencies are simply files in version control or a shared drive, Gradle provides powerful functionality to support this. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>支持依赖定义的自定义</em></span>：Gradle 的模块依赖给你在构建脚本中描述依赖项层次结构的能力。 </p><br><p><span class="emphasis"><em>Support for custom dependency definitions.</em></span>: Gradle's Module Dependencies give you the ability to describe the dependency hierarchy in the build script. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>一个完全可自定义的依赖解析的方法</em></span>：Gradle 为你提供了自定义解析规则的能力，让你可以轻松替换依赖。 </p><br><p><span class="emphasis"><em>A fully customizable approach to Dependency Resolution</em></span>: Gradle provides you with the ability to customize resolution rules making dependency substitution easy. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>完全兼容 Maven 和 Ivy </em></span>：如果你已经在 Maven POM 文件或 Ivy 文件中定义了依赖，Gradle 提供了一系列受欢迎的构建工具可以进行无缝集成。 </p><br><p><span class="emphasis"><em>Full Compatibility with Maven and Ivy</em></span>: If you have defined dependencies in a Maven POM or an Ivy file, Gradle provide seamless integration with a range of popular build tools. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>与现有依赖管理基础结构的集成</em></span>：Gradle 兼容 Maven 和 Ivy 仓库。如果你使用 Archiva， Nexus，或者是 Artifactory, Gradle 100% 兼容所有仓库的格式。 </p><br><p><span class="emphasis"><em>Integration with existing dependency management infrastructure</em></span>: Gradle is compatible with both Maven and Ivy repositories. If you use Archiva, Nexus, or Artifactory, Gradle is 100% compatible with all repository formats. </p></li>
     </ul>
    </div>
    <p> 成千上万的开源组件互相依赖，每个组件都有一系列的版本及不兼容性，随着构建变得越来越复杂，依赖管理常常出现各种问题。当一个构建的依赖树变得笨拙时，你的构建工具不应该强迫你对依赖管理采取单一、不灵活的做法。一个正确的构建系统必须被设计得很灵活，而 Gradle 可以应付任何情况。 <br>With hundreds of thousands of interdependent open source components each with a range of versions and incompatibilities, dependency management has a habit of causing problems as builds grow in complexity. When a build's dependency tree becomes unwieldy, your build tool shouldn't force you to adopt a single, inflexible approach to dependency management. A proper build system has to be designed to be flexible, and Gradle can handle any situation.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:dependency_management_and_migrations"></a>50.1.1. 为了迁移的灵活的依赖管理</h3>
        <h5 class="title"><a name="sub:dependency_management_and_migrations"></a>50.1.1.&nbsp;Flexible dependency management for migrations</h5>
       </div>
      </div>
     </div>
     <p> 依赖管理在从一个构建系统迁移到另一个的过程中尤其具有挑战性。如果你从一个像 Ant 或 Maven 这样的工具迁移到 Gradle，你可能会面临一些困难的情况。例如，一个常见的模式是，有一个 Ant 项目，而它保存在文件系统中的一些 jar 文件缺少版本号。其他的构建系统在迁移之前需要对这种方法进行大量的替换。使用 Gradle，你可以让你的新构建适配任何现有的依赖来源或依赖元数据。这使得增量迁移到 Gradle 比其他的要容易得多。在大多数的大项目中，构建迁移和对发展过程的任何更改都是增量的，因为大多数组织不能负担得起停止一切事情并迁移到依赖管理的构建工具的想法。 <br>Dependency management can be particularly challenging during a migration from one build system to another. If you are migrating from a tool like Ant or Maven to Gradle, you may be faced with some difficult situations. For example, one common pattern is an Ant project with version-less jar files stored in the filesystem. Other build systems require a wholesale replacement of this approach before migrating. With Gradle, you can adapt your new build to any existing source of dependencies or dependency metadata. This makes incremental migration to Gradle much easier than the alternative. On most large projects, build migrations and any change to development process is incremental because most organizations can't afford to stop everything and migrate to a build tool's idea of dependency management.</p>
     <p>即使你的项目使用一个自定义的依赖管理系统，或者是一些像 Eclipse 作为依赖管理的主数据的 .classpath 文件，那么可以很容易地写一个 Gradle 插件在 Gradle 中使用此数据。出于迁移的目的，这是在 Gradle 中的一种常用技术。（但是，一旦你已经迁移，远离 .classpath 文件，直接使用 Gradle 的依赖管理功能会是一个好主意。） <br>Even if your project is using a custom dependency management system or something like an Eclipse .classpath file as master data for dependency management, it is very easy to write a Gradle plugin to use this data in Gradle. For migration purposes this is a common technique with Gradle. (But, once you've migrated, it might be a good idea to move away from a .classpath file and use Gradle's dependency management features directly.)</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:dependency_management_and_java"></a>50.1.2. 依赖管理和 Java</h3>
        <h5 class="title"><a name="sub:dependency_management_and_java"></a>50.1.2.&nbsp;Dependency management and Java</h5>
       </div>
      </div>
     </div>
     <p>令人啼笑皆非的是，以其丰富的开源组件库著称的语言，Java 竟然没有库或者版本的概念。在 Java 中，没有标准的方法来告诉 JVM 你使用的是 3.0.5 版本的 Hibernate，也没有标准的方法来表明 <code class="literal">foo-1.0.jar</code> 依赖于 <code class="literal">bar-2.0.jar</code>。这导致了外部的解决方案通常都会基于构建工具。目前最受欢迎的解决方案是 Maven 和 Ivy。Maven 提供了一个完整的构建系统，而 Ivy 则完全着眼于依赖管理。 <br>It is ironic that in a language known for its rich library of open source components that Java has no concept of libraries or versions. In Java, there is no standard way to tell the JVM that you are using version 3.0.5 of Hibernate, and there is no standard way to say that <code class="literal">foo-1.0.jar</code> depends on <code class="literal">bar-2.0.jar</code>. This has led to external solutions often based on build tools. The most popular ones at the moment are Maven and Ivy. While Maven provides a complete build system, Ivy focuses solely on dependency management.</p>
     <p>这两种工具都依赖于描述符 XML 文件，包含有关具体某个 jar 的依赖的信息。这两者都使用了存储库，在存储库中实际的 jar 文件和它们的描述文件都放在一起，而且这两者通过窗口或其他的方式都提供了 jar 版本冲突的解决方案。这两者都已成为解决依赖冲突的标准，而 Gradle 最初使用的是 Ivy 引擎的依赖管理。Gradle 已经取代了 Ivy 上的直接依赖，而采用了原生的 Gradle 依赖解决引擎，它支持许多的依赖解决方案的方法，包括 POM 文件和 Ivy 描述文件。 <br>Both tools rely on descriptor XML files, which contain information about the dependencies of a particular jar. Both also use repositories where the actual jars are placed together with their descriptor files, and both offer resolution for conflicting jar versions in one form or the other. Both have emerged as standards for solving dependency conflicts, and while Gradle originally used Ivy under the hood for its dependency management. Gradle has replaced this direct dependency on Ivy with a native Gradle dependency resolution engine which supports a range of approaches to dependency resolution including both POM and Ivy descriptor files.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependency_management_overview"></a>50.2. 依赖管理的最佳实践</h2>
       <h4 class="title"><a name="sec:dependency_management_overview"></a>50.2.&nbsp;Dependency Management Best Practices</h4>
      </div>
     </div>
    </div>
    <p>由于 Gradle 对依赖管理有强烈的主张，该工具使你可以选择两个选项之间：遵循推荐的最佳实践或支持任何你能想到的类型的模式。本节概述 Gradle 项目推荐的管理依赖的最佳实践。 <br>While Gradle has strong opinions on dependency management, the tool gives you a choice between two options: follow recommended best practices or support any kind of pattern you can think of. This section outlines the Gradle project's recommended best practices for managing dependencies.</p>
    <p>不管用什么语言，对每个项目而言，适当的依赖管理是很重要的。从一个由 Java 编写的依赖了数以百计开源库的复杂企业应用，再到依赖少量库的最简单的 Clojure 应用，依赖管理的办法大不相同，并且可以依赖于目标的技术、应用程序部署的方法和项目的性质。项目捆绑作为可重用的库，比起企业应用集成到更大的软件和基础设施的系统中，可能有不同的要求。尽管这一要求变化很大，Gradle 项目建议所有项目都遵循这套核心规则： <br>No matter what the language, proper dependency management is important for every project. From a complex enterprise application written in Java depending on hundreds of open source libraries to the simplest Clojure application depending on a handful of libraries, approaches to dependency management vary widely and can depend on the target technology, the method of application deployment, and the nature of the project. Projects bundled as reusable libraries may have different requirements than enterprise applications integrated into much larger systems of software and infrastructure. Despite this wide variation of requirements, the Gradle project recommends that all projects follow this set of core rules:</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:versioning_the_jar_name"></a>50.2.1. 在文件名中包含版本号（版本化 jar 文件）</h3>
        <h5 class="title"><a name="sub:versioning_the_jar_name"></a>50.2.1.&nbsp;Put the Version in the Filename (Version the jar)</h5>
       </div>
      </div>
     </div>
     <p>在文件名中库的版本必须是容易辨认的。Jar 的版本通常是在清单文件中，当你要检查一个项目时它并不显而易见。如果有人让你看 20 个 jar 文件，你更喜欢哪一种？一个文件命名为 <code class="filename">beanutils-beanutils-1.3.jar</code> 的集合，还是文件命名为 <code class="filename">spring.jar</code> 的集合？如果依赖的文件名称带有版本号，那么将更容易快速确定依赖的版本。 <br>The version of a library must be easy to recognize in the filename. While the version of a jar is usually in the Manifest file, it isn't readily apparent when you are inspecting a project. If someone asks you to look at a collection of 20 jar files, which would you prefer? A collection of files with names like <code class="filename">commons-beanutils-1.3.jar</code> or a collection of files with names like <code class="filename">spring.jar</code>? If dependencies have file names with version numbers it is much easier to quickly identify the versions of your dependencies.</p>
     <p>如果版本不清楚，你可能引入一些很难找到的微妙的错误。例如可能有一个项目使用 Hibernate 2.5。想一下一个开发人员决定在她的机器安装 3.0.5 的版本，以修复一个关键的安全 bug，但她忘记通知其他团队这个变化。她可能成功地解决了这个安全 bug，但她也可能有引入一些 bug 到代码库中，因为项目用到了 Hibernate 现在弃用的功能。一周后在集成的机器上可能会有一个异常，而这个异常无法在任何人的机器上复现。然后多个开发人员花了数天的时间在这个问题上，终于意识到如果他们知道 Hibernate 已经从 2.5 升级到 3.0.5，这个错误会很容易发现。 <br>If versions are unclear you can introduce subtle bugs which are very hard to find. For example there might be a project which uses Hibernate 2.5. Think about a developer who decides to install version 3.0.5 of Hibernate on her machine to fix a critical security bug but forgets to notify others in the team of this change. She may address the security bug successfully, but she also may have introduced subtle bugs into a codebase that was using a now-deprecated feature from Hibernate. Weeks later there is an exception on the integration machine which can't be reproduced on anyone's machine. Multiple developers then spend days on this issue only finally realising that the error would have easy to uncover if they knew that Hibernate had been upgraded from 2.5 to 3.0.5.</p>
     <p>在 jar 文件中包含版本号提高了在你的项目中的表现，并且让它们更易于维护。这种做法也减少了潜在的错误。 <br>Versions in jar names increase the expressiveness of your project and make them easier to maintain. This practice also reduces the potential for error.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:transitive_dependency_management"></a>50.2.2. 管理传递依赖</h3>
        <h5 class="title"><a name="sub:transitive_dependency_management"></a>50.2.2.&nbsp;Manage transitive dependencies</h5>
       </div>
      </div>
     </div>
     <p>传递依赖管理是一种技术，让你的项目能够依赖那些反过来依赖其他库的库。这种递归模式传递依赖的结果是，在一个依赖树中，会包含你的项目的第一级依赖、第二级依赖，等等。如果你不把你的依赖作为层次结构树的第一级和第二级依赖的模型，那么在对未组织的依赖进行混乱的组装之后，就会很容易地失去控制。考虑 Gradle 项目本身，虽然 Gradle 仅有几个直接的第一级依赖，当 编译 Gradle 时在它的类路径上会需要超过一百个的依赖。在更大的规模上，使用 Spring，Hibernate和其他的库，旁边数百或数千个内部项目的企业应用，也有非常大的依赖树。 <br>Transitive dependency management is a technique that enables your project to depend on libraries which, in turn, depend on other libraries. This recursive pattern of transitive dependencies results in a tree of dependencies including your project's first-level dependencies, second-level dependencies, and so on. If you don't model your dependencies as a hierarchical tree of first-level and second-level dependencies it is very easy to quickly lose control over an assembled mess of unstructured dependencies. Consider the Gradle project itself, while Gradle only has a few direct, first-level dependencies, when Gradle is compiled it needs more that one hundred dependencies on the classpath. On a far larger scale, Enterprise projects using Spring, Hibernate, and other libraries, alongside hundreds or thousands of internal projects can have very large dependency trees.</p>
     <p>当这些大的依赖树需要更改时，你经常得解决一些依赖的版本冲突。比如说一个开源库需要一个日志库的一个版本，而另一个库需要日志库的另一个版本。Gradle 和其他的构建工具都能够处理这种关系树和解决冲突问题，但不同的是，Gradle 让你可以控制传递依赖和冲突的解决。 <br>When these large dependency trees need to change, you'll often have to solve some dependency version conflicts. Say one open source library needs one version of a logging library and a another uses an alternative version. Gradle and other build tools all have the ability to solve this dependency tree and resolve conflicts, but what differentiates Gradle is the control it gives you over transitive dependencies and conflict resolution.</p>
     <p>虽然你可以尝试手动管理这个问题，你很快就会发现这种方法不能扩展。如果你想要摆脱第一级的依赖，你不能真正确定还有哪些 jar 文件你是需要删除的。第一级依赖的依赖项也可能是第一级依赖本身，或者也可能是另一个第一级依赖的传递依赖。如果你尝试自己管理传递依赖，最终的结果是你的构建会变得很脆弱：没有人敢去改变你的依赖，因为破坏构建的风险太高。项目的类路径会变得一片狼藉，并且，如果类路径出现问题时，那简直就是人间地狱。 <br>While you could try to manage this problem manually, you will quickly find that this approach doesn't scale. If you want to get rid of a first level dependency you really can't be sure which other jars you should remove. A dependency of a first level dependency might also be a first level dependency itself, or it might be a transitive dependency of yet another first level dependency. If you try to manage transitive dependencies yourself, the end of the story is that your build becomes brittle: no one dares to change your dependencies because the risk of breaking the build is too high. The project classpath becomes a complete mess, and, if a classpath problem arises, hell on earth invites you for a ride.</p>
     <div class="note">
      <span class="emphasis"><em>注：</em> <br><em>NOTE:</em></span>在一个项目中，我们发现在类路径中有一个神秘、LDAP 相关的 jar 包。没有代码引用这个 jar 包，这个 jar 包也与该项目没有任何连接。没人能弄清楚这个 jar 包是干什么用的，直到它被从构建中移除，然后应用在试图向 LDAP 进行身份验证的时候，遇到了很大的性能问题。这个神秘的 jar 包是一个必需传递的，第四级的依赖，很容易被忽略，因为没有人会费心去使用托管的传递依赖。 
     </div>
     <p>Gradle 向你提供了不同的方式来表达第一级的和传递的依赖。通过 Gradle 你可以混合使用和适配一些方法；例如，你可以在 SCM 中存储你的 jar 包，而不需要 XML 描述符文件，并且仍然使用传递依赖管理。 <br>Gradle offers you different ways to express first-level and transitive dependencies. With Gradle you can mix and match approaches; for example, you could store your jars in an SCM without XML descriptor files and still use transitive dependency management.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:version_conflicts"></a>50.2.3. 解决版本冲突的问题</h3>
        <h5 class="title"><a name="sub:version_conflicts"></a>50.2.3.&nbsp;Resolve version conflicts</h5>
       </div>
      </div>
     </div>
     <p>相同的 jar 包的冲突版本应该被检测到，并且要么解决，要么抛出异常。如果你不使用传递依赖管理，版本冲突没被发现，那么在类路径中无法预测的顺序，将导致不知道会使用哪一个版本的依赖。对于许多开发人员都会更改依赖的大型项目，成功的构建将会少之又少，因为依赖的顺序可能会直接影响到构建是否成功（或者在产品中是否会出现一个 bug）。 <br>Conflicting versions of the same jar should be detected and either resolved or cause an exception. If you don't use transitive dependency management, version conflicts are undetected and the often accidental order of the classpath will determine what version of a dependency will win. On a large project with many developers changing dependencies, successful builds will be few and far between as the order of dependencies may directly affect whether a build succeeds or fails (or whether a bug appears or disappears in production).</p>
     <p>如果你还没有处理过在类路径中 jar 包版本冲突的麻烦，这里有一个小趣闻等着你。在一个有30个子模块的大型项目中，向子项目添加的一个依赖改变了类路径的顺序， Spring 2.5 与老的 2.4 版本的顺序被交换。虽然可以继续构建，开发者已经开始注意到在生产中出现了各种令人惊讶（和惊人可怕）的 bug。然而，更糟糕的是，无意降低版本的 Spring 向系统引入了几个安全漏洞，现在需要在整个组织中进行全面的安全审核。 <br>If you haven't had to deal with the curse of conflicting versions of jars on a classpath, here is a small anecdote of the fun that awaits you. In a large project with 30 submodules, adding a dependency to a subproject changed the order of a classpath, swapping Spring 2.5 for an older 2.4 version. While the build continued to work, developers were starting to notice all sorts of surprising (and surprisingly awful) bugs in production. Worse yet, this unintentional downgrade of Spring introduced several security vulnerabilities into the system, which now required a full security audit throughout the organization.</p>
     <p>总之，版本冲突是很不好的，你应该管理你的传递依赖，以避免它们。你也可能想要了解版本冲突用到的地方，并且在你的整个组织中统一一个指定版本的依赖。通过一个好的冲突报告工具，像 Gradle，这些信息可以用于与整个组织沟通，并在一个单一的版本上实现标准化。<span class="emphasis"><em>如果你觉得你不会发生版本冲突，再想想。</em> </span>不同的第一级依赖，依赖于一系列不同的重叠版本的其他依赖，这种情况是很常见的，而 JVM 还不能提供简单的方法，使得能在类路径中让相同的 jar 包可以有不同的版本（请参阅<a class="xref" href="dependency_management.html#sub:dependency_management_and_java">第 50.1.2 节，“依赖管理和 Java”</a>）。 <br>In short, version conflicts are bad, and you should manage your transitive dependencies to avoid them. You might also want to learn where conflicting versions are used and consolidate on a particular version of a dependency across your organization. With a good conflict reporting tool like Gradle, that information can be used to communicate with the entire organization and standardize on a single version. <span class="emphasis"><em>If you think version conflicts don't happen to you, think again.</em></span> It is very common for different first-level dependencies to rely on a range of different overlapping versions for other dependencies, and the JVM doesn't yet offer an easy way to have different versions of the same jar in the classpath (see <a class="xref" href="dependency_management.html#sub:dependency_management_and_java">Section&nbsp;50.1.2, “Dependency management and Java”</a>).</p>
     <p>Gradle 提供了以下的冲突解决策略：<br>Gradle offers the following conflict resolution strategies:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"><span class="emphasis"><em>Newest</em></span>：使用最新版本的依赖这是 Gradle 的默认策略，只要版本都能向后兼容，往往是合适的选择。 <br><span class="emphasis"><em>Newest</em></span>: The newest version of the dependency is used. This is Gradle's default strategy, and is often an appropriate choice as long as versions are backwards-compatible.</li>
       <li class="listitem"><span class="emphasis"><em>Fail</em></span>：一个版本冲突将导致构建失败。这种策略强制在构建脚本中明确地解决所有的版本冲突。有关如何显式选择一个特定版本的详细信息，请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code> </a> 。 <br><span class="emphasis"><em>Fail</em></span>: A version conflict results in a build failure. This strategy enforces that all version conflicts are resolved explicitly in the build script. See <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for details on how to explicitly choose a particular version.</li>
      </ul>
     </div>
     <p>虽然上面介绍的策略通常足够解决大部分的冲突，但是 Gradle 也提供更细粒度的机制，以解决版本冲突：<br>While the strategies introduced above are usually enough to solve most conflicts, Gradle provides more fine-grained mechanisms to resolve version conflicts:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"> <span class="emphasis"><em>强制</em></span>配置第一级依赖。如果冲突中的依赖已经是第一级的依赖，那么这种方法会很有用。请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>中的示例。 <br>Configuring a first level dependency as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is already a first level dependency. See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>.</li>
       <li class="listitem"> <span class="emphasis"><em>强制</em></span>配置任何依赖项（不管是否可传递）。如果冲突中的依赖是传递依赖，那么这种方法会很有用。它也可以用于强制第一级依赖的版本。请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>中的示例。<br>Configuring any dependency (transitive or not) as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is a transitive dependency. It also can be used to force versions of first level dependencies. See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a></li>
       <li class="listitem"> 依赖解析规则是一个在 Gradle 1.4 引进的<a class="link" href="feature_lifecycle.html">孵化中</a>的功能，让你可以对特定的依赖细粒度地控制所选定的版本。 <br>Dependency resolve rules are an <a class="link" href="feature_lifecycle.html">incubating</a> feature introduced in Gradle 1.4 which give you fine-grained control over the version selected for a particular dependency.</li>
      </ul>
     </div>
     <p>为了解决版本冲突问题，报告依赖关系图也是很有帮助的。这些报告是依赖管理的另一个功能。<br>To deal with problems due to version conflicts, reports with dependency graphs are also very helpful. Such reports are another feature of dependency management.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:dynamic_versions_and_changing_modules"></a>50.2.4. 使用动态版本和变化的模块</h3>
        <h5 class="title"><a name="sub:dynamic_versions_and_changing_modules"></a>50.2.4.&nbsp;Use Dynamic Versions and Changing Modules</h5>
       </div>
      </div>
     </div>
     <p>有许多情况，是你想要使用一个特定依赖的最新版本，或者是某个版本范围内的最新版。这可以是在开发中需要，或者你可能正在开发一个库，它被设计为使用一个范围内的依赖版本。你可以通过使用<span class="emphasis"><em>动态版本</em></span>很容易地依赖这些不断变化的依赖。一个动态的版本可以是一个版本范围（例如<code class="literal">2.+</code>），也可以是表示可用的最新版本的占位符（例如<code class="literal">latest.integration</code>）。 <br>There are many situation when you want to use the latest version of a particular dependency, or the latest in a range of versions. This can be a requirement during development, or you may be developing a library that is designed to work with a range of dependency versions. You can easily depend on these constantly changing dependencies by using a <span class="emphasis"><em>dynamic version</em></span>. A dynamic version can be either a version range (e.g. <code class="literal">2.+</code>) or it can be a placeholder for the latest version available (e.g. <code class="literal">latest.integration</code>).</p>
     <p>另外，你请求的模块随着时间推移，即使是同一版本，有时也可能改变了。这种<span class="emphasis"><em>变化模块</em></span>的类型的一个例子是 Maven<code class="literal">SNAPSHOT</code>模块，它总是指向最新发布的构件。换句话说，一个标准的 Maven snapshot 是一个这样的模块，它永远不会不变，可以说，它是“不断变化的模块”。 <br>Alternatively, sometimes the module you request can change over time, even for the same version. An example of this type of <span class="emphasis"><em>changing module</em></span> is a Maven <code class="literal">SNAPSHOT</code> module, which always points at the latest artifact published. In other words, a standard Maven snapshot is a module that never stands still so to speak, it is a "changing module".</p>
     <p><span class="emphasis"><em>动态版本</em></span>和<span class="emphasis"><em>变化模块</em></span>的主要区别是，当你解析一个<span class="emphasis"><em>动态版本</em></span>时，你会得到真正的、 静态的版本作为模块名称。当你解析一个<span class="emphasis"><em>变化模块</em></span>时，这个 artifacts 使用你请求的版本进行命名，但下层的 artifacts 可能随时会有变化。 <br>The main difference between a <span class="emphasis"><em>dynamic version</em></span> and a <span class="emphasis"><em>changing module</em></span> is that when you resolve a <span class="emphasis"><em>dynamic version</em></span>, you'll get the real, static version as the module name. When you resolve a <span class="emphasis"><em>changing module</em></span>, the artifacts are named using the version you requested, but the underlying artifacts may change over time.</p>
     <p>默认情况下，Gradle 对动态版本和变化模块的缓存时间是24小时。你可以使用<a class="link" href="dependency_management.html#sec:cache_command_line_options">命令行选项</a>重写默认的缓存模式。你可以通过<code class="literal">resolution strategy</code>修改你的构建的缓存到期时间（见<a class="xref" href="dependency_management.html#sec:controlling_caching">第 50.9.3 节，“调整控制依赖缓存”</a>）。 <br>By default, Gradle caches dynamic versions and changing modules for 24 hours. You can override the default cache modes using <a class="link" href="dependency_management.html#sec:cache_command_line_options">command line options</a>. You can change the cache expiry times in your build using the <code class="literal">resolution strategy</code> (see <a class="xref" href="dependency_management.html#sec:controlling_caching">Section&nbsp;50.9.3, “Fine-tuned control over dependency caching”</a>).</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sub:configurations"></a>50.3. 依赖配置</h2>
       <h4 class="title"><a name="sub:configurations"></a>50.3.&nbsp;Dependency configurations</h4>
      </div>
     </div>
    </div>
    <p>在 Gradle 中，依赖被分组到配置中。配置有一个名字和许多属性，并且它们能够互相继承。许多 Gradle 插件会向你的 project 添加预定义的配置。例如，Java 插件会添加一些配置来表示它所需要的不同的类路径。详细信息请参阅<a class="xref" href="java_plugin.html#sec:java_plugin_and_dependency_management">第 23.5 节，“依赖管理”</a> 。当然，你可以添加自定义配置到这上面。关于自定义配置，有许多的用例。这是非常方便的，例如添加依赖时不需要构建或测试你的软件（比如，将会与发布的软件一起的额外的 JDBC 驱动程序）。 <br>In Gradle dependencies are grouped into configurations. Configurations have a name, a number of other properties, and they can extend each other. Many Gradle plugin add pre-defined configurations to your project. The Java plugin, for example, adds some configurations to represent the various classpaths it needs. see <a class="xref" href="java_plugin.html#sec:java_plugin_and_dependency_management">Section&nbsp;23.5, “Dependency management”</a> for details. Of course you can add custom configurations on top of that. There are many use cases for custom configurations. This is very handy for example for adding dependencies not needed for building or testing your software (e.g. additional JDBC drivers to be shipped with your distribution).</p>
    <p> 一个项目的配置被一个 <code class="literal">configurations</code> 对象所管理。你传给这个 configurations 对象的闭包会通过它对应的 API 被应用。要了解更多关于此 API 的内容，可以看看<a class="ulink" href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" target="_top"><code class="classname">ConfigurationContainer</code></a>。 <br>A project's configurations are managed by a <code class="literal">configurations</code> object. The closure you pass to the configurations object is applied against its API. To learn more about this API have a look at <a class="ulink" href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" target="_top"><code class="classname">ConfigurationContainer</code></a>.</p>
    <p>如果要定义配置：<br>To define a configuration:</p>
    <div class="example">
     <a name="defineConfiguration"></a>
     <p class="title"><b>示例 50.1. 配置的定义 - Example&nbsp;50.1.&nbsp;Definition of a configuration</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">configurations {
    compile
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p>如果要访问配置：<br>To access a configuration:</p>
    <div class="example">
     <a name="defineConfiguration"></a>
     <p class="title"><b>示例 50.2. 访问配置 - Example&nbsp;50.2.&nbsp;Accessing a configuration</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">println configurations.compile.name
println configurations[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>].name</pre>
     </div>
    </div>
    <br class="example-break">
    <p>配置一个配置：<br>To configure a configuration:</p>
    <div class="example">
     <a name="defineConfiguration"></a>
     <p class="title"><b>示例 50.3. 配置一个配置 - Example&nbsp;50.3.&nbsp;Configuration of a configuration</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">configurations {
    compile {
        description = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile classpath'</span>
        transitive = true
    }
    runtime {
        extendsFrom compile
    }
}
configurations.compile {
    description = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile classpath'</span>
}</pre>
     </div>
    </div>
    <br class="example-break">
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:how_to_declare_your_dependencies"></a>50.4. 如何声明依赖</h2>
       <h4 class="title"><a name="sec:how_to_declare_your_dependencies"></a>50.4.&nbsp;How to declare your dependencies</h4>
      </div>
     </div>
    </div>
    <p>你可以声明几种不同类型的依赖： <br>There are several different types of dependencies that you can declare:</p>
    <div xmlns:xslthl="http://xslthl.sf.net" class="table">
     <p class="title"><b>表 50.1. 依赖类型 - Table&nbsp;50.1.&nbsp;Dependency types</b></p>
     <div class="table-contents">
      <table id="N14C92">
       <thead>
        <tr> 
         <td>类型<br>Type</td> 
         <td>描述<br>Description</td> 
        </tr>
       </thead>
       <tbody>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:module_dependencies">外部模块依赖</a> <br><a class="link" href="dependency_management.html#sub:module_dependencies">External module dependency</a></td> 
         <td>对一些仓库中的外部模块的依赖<br>A dependency on an external module in some repository.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:project_dependencies">项目依赖</a> <br><a class="link" href="dependency_management.html#sub:project_dependencies">Project dependency</a></td> 
         <td>在同一个构建中对另一个项目的依赖<br>A dependency on another project in the same build.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:file_dependencies">文件依赖</a> <br><a class="link" href="dependency_management.html#sub:file_dependencies">File dependency</a></td> 
         <td>对本地文件系统中的一些文件的依赖<br>A dependency on a set of files on the local filesystem.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:client_module_dependencies">客户端模块依赖</a> <br><a class="link" href="dependency_management.html#sub:client_module_dependencies">Client module dependency</a></td> 
         <td>对外部模块的依赖，该块部模块的 artifacts 存储于一些仓库中，但是模块的元数据由本地构建指定。当你想要重写模块的元数据时，你可以使用这种类型的依赖。 <br>A dependency on an external module, where the artifacts are located in some repository but the module meta-data is specified by the local build. You use this kind of dependency when you want to override the meta-data for the module.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:api_dependencies">Gradle API 依赖</a> <br><a class="link" href="dependency_management.html#sub:api_dependencies">Gradle API dependency</a></td> 
         <td>对当前的 Gradle 版本的 API 的依赖当你正在开发自定义的 Gradle 插件和任务类型时，你可以使用这种类型的依赖。 <br>A dependency on the API of the current Gradle version. You use this kind of dependency when you are developing custom Gradle plugins and task types.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:groovy_dependencies">本地的 Groovy 依赖</a> <br><a class="link" href="dependency_management.html#sub:groovy_dependencies">Local Groovy dependency</a></td> 
         <td>对当前的 Gradle 所使用的 Groovy 版本的依赖。当你正在开发自定义的 Gradle 插件和任务类型时，你可以使用这种类型的依赖。 <br>A dependency on the Groovy version used by the current Gradle version. You use this kind of dependency when you are developing custom Gradle plugins and task types.</td> 
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:module_dependencies"></a>50.4.1. 外部模块依赖</h3>
        <h5 class="title"><a name="sub:module_dependencies"></a>50.4.1.&nbsp;External module dependencies</h5>
       </div>
      </div>
     </div>
     <p>外部模块依赖是最常见的依赖。它们引用外部仓库中的模块。 <br>External module dependencies are the most common dependencies. They refer to a module in an external repository.</p>
     <div class="example">
      <a name="moduleDependencies"></a>
      <p class="title"><b>示例 50.4. 模块依赖 - Example&nbsp;50.4.&nbsp;Module dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-core'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework:spring-core:2.5'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework:spring-aop:2.5'</span>
    runtime(
        [group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-core'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>],
        [group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-aop'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>]
    )
    runtime(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate:hibernate:3.0.5'</span>) {
        transitive = true
    }
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hibernate'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'3.0.5'</span>, transitive: true
    runtime(group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hibernate'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'3.0.5'</span>) {
        transitive = true
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>有关更多的例子和完整的参考，请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code> </a> 。 <br>See <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> for more examples and a complete reference.</p>
     <p>Gradle 为模块依赖提供了不同的标记法。有 string 标记法和 map 标记法。模块依赖有一个 API，用于进行进一步的配置。要了解所有该 API 的内容，可以参阅<a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" target="_top"><code class="classname">ExternalModuleDependency</code></a> 。该 API 提供了一些属性和配置方法。通过 string 标记法，你可以定义一个属性的子集。而通过使用 map 标记法，你可以定义所有的属性。要访问完整的 API，使用 map 或 string 标记法，你可以把单个的依赖与一个闭包一起指定给一个配置。 <br>Gradle provides different notations for module dependencies. There is a string notation and a map notation. A module dependency has an API which allows for further configuration. Have a look at <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" target="_top"><code class="classname">ExternalModuleDependency</code></a> to learn all about the API. This API provides properties and configuration methods. Via the string notation you can define a subset of the properties. With the map notation you can define all properties. To have access to the complete API, either with the map or with the string notation, you can assign a single dependency to a configuration together with a closure.</p>
     <p>如果你定义了一个模块依赖，Gradle 会在仓库中查找相应的模块描述符文件（<code class="filename">pom.xml</code>或<code class="filename">ivy.xml</code>）。如果存在此类模块描述符文件，它会进行分析，并下载此模块的 artifacts （例如<code class="filename">hibernate-3.0.5.jar</code>）以及其依赖项（例如 cglib）。如果不存在这样的模块描述符文件，Gradle 会查找一个<code class="filename">hibernate-3.0.5.jar</code> 文件。在 Maven 中，一个模块仅能有一个 artifact。在 Gradle 和 Ivy 中，一个模块可以具有多个 artifacts。每个 artifact 可以有一组不同的依赖。 <br>If you declare a module dependency, Gradle looks for a corresponding module descriptor file (<code class="filename">pom.xml</code> or <code class="filename">ivy.xml</code>) in the repositories. If such a module descriptor file exists, it is parsed and the artifacts of this module (e.g. <code class="filename">hibernate-3.0.5.jar</code>) as well as its dependencies (e.g. cglib) are downloaded. If no such module descriptor file exists, Gradle looks for a file called <code class="filename">hibernate-3.0.5.jar</code> to retrieve. In Maven, a module can have one and only one artifact. In Gradle and Ivy, a module can have multiple artifacts. Each artifact can have a different set of dependencies.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:multi_artifact_dependencies"></a>50.4.1.1. 依赖有多个 artifacts 的模块</h4>
         <h6 class="title"><a name="ssub:multi_artifact_dependencies"></a>50.4.1.1.&nbsp;Depending on modules with multiple artifacts</h6>
        </div>
       </div>
      </div> 正如前面提到的，一个 Maven 模块都只有一个 artifact。因此，当你的项目依赖于一个 Maven 模块时，这个模块的 artifact 是哪一个会很明显。而使用 Gradle 或Ivy的话，情况就不同了。Ivy 的依赖描述符（
      <code class="filename">ivy.xml</code>）可以定义多个 artifact。有关更多的信息，请参阅
      <code class="filename">ivy.xml</code>引用的Ivy。在 Gradle 中，当你声明一个对 Ivy 模块的依赖时，实际上你是在那个模块的 
      <code class="literal">default</code> 配置上声明了一个依赖。所以实际上，你依赖的 artifacts 集（通常是一些 jar 包） 是与该模块的 
      <code class="literal">default</code> 配置相关联的 artifacts 集。以下是一些比较重要的情况： 
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">一个模块的 <code class="literal">default</code> 配置包含了不希望有的 artifacts。一个依赖只是声明了所需的 artifacts ，而不是依赖整个配置。 <br>The <code class="literal">default</code> configuration of a module contains undesired artifacts. Rather than depending on the whole configuration, a dependency on just the desired artifacts is declared.</li>
        <li class="listitem">所需的 artifact 属于一个非 <code class="literal">default</code>的配置。这个配置被显式地命名为这个依赖声明的一部分。 <br>The desired artifact belongs to a configuration other than <code class="literal">default</code>. That configuration is explicitly named as part of the dependency declaration.</li>
       </ul>
      </div> 还有一些其他的情况，需要调整依赖声明。请参阅 
      <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> 的例子和声明依赖的完整参考。 
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:artifact_dependencies"></a>50.4.1.2.&nbsp;Artifact only notation</h4>
         <h6 class="title"><a name="ssub:artifact_dependencies"></a>50.4.1.2.&nbsp;Artifact only notation</h6>
        </div>
       </div>
      </div>
      <p>如上所述，如果找不到模块的描述符文件，默认情况下 Gradle 会下载一个与模块的名称相同的 jar 文件。但有时候，即使存储库包含了模块描述符，而你只是想下载 artifact jar而不下载它的依赖项。<sup>[<a href="#ftn.N14D3A" name="N14D3A" class="footnote">14</a>]</sup> 而有时候你想要从一个仓库中下载一个 zip，而它没有模块描述符。Gradle 提供了一个 <span class="emphasis"><em>artifact only</em></span> notation 用于这些案例情况——只是对你想要下载的扩展前加个 <code class="literal">'@'</code> 标志： <br>As said above, if no module descriptor file can be found, Gradle by default downloads a jar with the name of the module. But sometimes, even if the repository contains module descriptors, you want to download only the artifact jar, without the dependencies. <sup>[<a href="#ftn.N14D3A" name="N14D3A" class="footnote">14</a>]</sup> And sometimes you want to download a zip from a repository, that does not have module descriptors. Gradle provides an <span class="emphasis"><em>artifact only</em></span> notation for those use cases - simply prefix the extension that you want to be downloaded with <code class="literal">'@'</code> sign:</p>
      <div class="example">
       <a name="artifactOnly"></a>
       <p class="title"><b>示例 505.&nbsp;Artifact only notation - Example&nbsp;50.5.&nbsp;Artifact only notation</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">dependencies {
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.groovy:groovy:2.2.0@jar"</span>
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.groovy'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.2.0'</span>, ext: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'jar'</span>
}</pre>
       </div>
      </div>
      <p><br class="example-break"> 一个 artifact only notation 创建了一个模块依赖，它只下载指定扩展名的 artifact 文件。现有的模块描述符将被忽略。 <br><br class="example-break"> An artifact only notation creates a module dependency which downloads only the artifact file with the specified extension. Existing module descriptors are ignored.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:classifiers"></a>50.4.1.3.&nbsp;Classifiers</h4>
         <h6 class="title"><a name="sub:classifiers"></a>50.4.1.3.&nbsp;Classifiers</h6>
        </div>
       </div>
      </div>
      <p>Maven 依赖管理有 classifier 的概念。<sup>[<a href="#ftn.N14D58" name="N14D58" class="footnote">15</a>]</sup> 而 Gradle 支持这一点。如果你想从一个 Maven 仓库中获取 classified 依赖项，你可以这样写： <br>The Maven dependency management has the notion of classifiers. <sup>[<a href="#ftn.N14D58" name="N14D58" class="footnote">15</a>]</sup> Gradle supports this. To retrieve classified dependencies from a Maven repository you can write:</p>
      <div class="example">
       <a name="classifier"></a>
       <p class="title"><b>示例 50.6. 使用 classifier 的依赖 - Example&nbsp;50.6.&nbsp;Dependency with classifier</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">compile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.test.classifiers:service:1.0:jdk15@jar"</span>
    otherConf group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.test.classifiers'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'service'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>, classifier: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'jdk14'</span></pre>
       </div>
      </div>
      <br class="example-break">
      <p>如上面的第一行所示，classifiers 可以与artifact only notation 一起使用。 <br>As can be seen in the first line above, classifiers can be used together with artifact only notation.</p>
     </div>
     <p>它可以轻松地遍历一个配置的依赖 artifacts：<br>It is easy to iterate over the dependency artifacts of a configuration:</p>
     <div class="example">
      <a name="externalDependencies"></a>
      <p class="title"><b>示例 50.7. 遍历一个配置 - Example&nbsp;50.7.&nbsp;Iterating over a configuration</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">task listJars &lt;&lt; {
    configurations.compile.each { File file -&gt; println file.name }
}</pre>
       <p><strong class="userinput"><code>gradle -q listJars</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q listJars</code></strong></p>
       <pre class="screen">&gt; gradle -q listJars
hibernate-core-3.6.7.Final.jar
antlr-2.7.6.jar
commons-collections-3.1.jar
dom4j-1.6.1.jar
hibernate-commons-annotations-3.2.0.Final.jar
hibernate-jpa-2.0-api-1.0.1.Final.jar
jta-1.1.jar
slf4j-api-1.6.1.jar</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:client_module_dependencies"></a>50.4.2. 客户端模块依赖</h3>
        <h5 class="title"><a name="sub:client_module_dependencies"></a>50.4.2.&nbsp;Client module dependencies</h5>
       </div>
      </div>
     </div>
     <p>客户端模块依赖允许直接在构建脚本中声明<span class="emphasis"><em>传递</em></span>依赖。它们是外部库的模块描述符的替代者。 <br>Client module dependencies allow to declare <span class="emphasis"><em>transitive</em></span> dependencies directly in the build script. They are a replacement for a module descriptor in an external repository.</p>
     <div class="example">
      <a name="client-modules"></a>
      <p class="title"><b>示例 50.8. 客户端模块依赖 - 传递依赖 - Example&nbsp;50.8.&nbsp;Client module dependencies - transitive dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.codehaus.groovy:groovy-all:2.2.0"</span>) {
        dependency(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"commons-cli:commons-cli:1.0"</span>) {
            transitive = false
        }
        module(group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.apache.ant'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ant'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.9.3'</span>) {
            dependencies <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant-launcher:1.9.3@jar"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant-junit:1.9.3"</span>
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>这里定义了一个对 Groovy 的依赖。Groovy 本身具有依赖。但 Gradle 不会去查找一个 XML 描述符来找出它的依赖，而是从构建文件中获取信息。一个客户端模块的依赖可以是正常的模块依赖，或者是 artifact 依赖项或是另一个客户端模块。可以看一看 API 文档：<a class="ulink" href="../javadoc/org/gradle/api/artifacts/ClientModule.html" target="_top"> <code class="classname">ClientModule</code> </a> <br>This declares a dependency on Groovy. Groovy itself has dependencies. But Gradle does not look for an XML descriptor to figure them out but gets the information from the build file. The dependencies of a client module can be normal module dependencies or artifact dependencies or another client module. Have also a look at the API documentation: <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ClientModule.html" target="_top"><code class="classname">ClientModule</code></a></p>
     <p>在当前版本客户端模块有一个缺陷。假设你的项目是一个库，你想要这个库上传到你公司的 Maven 或Ivy 仓库。Gradle 会将你的项目的 jar 包以及这仆依赖的 XML 描述文件上传到公司仓库。如果你使用了客户端模块，在 XML 描述符文件中的依赖声明就会不正确。我们将在未来版本的 Gradle 修正这一点。 <br>In the current release client modules have one limitation. Let's say your project is a library and you want this library to be uploaded to your company's Maven or Ivy repository. Gradle uploads the jars of your project to the company repository together with the XML descriptor file of the dependencies. If you use client modules the dependency declaration in the XML descriptor file is not correct. We will improve this in a future release of Gradle.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:project_dependencies"></a>50.4.3. 项目依赖</h3>
        <h5 class="title"><a name="sub:project_dependencies"></a>50.4.3.&nbsp;Project dependencies</h5>
       </div>
      </div>
     </div>
     <p>对于多项目构建，Gradle 能区分外部依赖与作为多项目构建的一部分的某个项目上的依赖。对于后者，你可以声明<em class="firstterm">项目依赖</em>。 <br>Gradle distinguishes between external dependencies and dependencies on projects which are part of the same multi-project build. For the latter you can declare <em class="firstterm">Project Dependencies</em>.</p>
     <div class="example">
      <a name="project-dependencies"></a>
      <p class="title"><b>50.9. 项目依赖 - Example&nbsp;50.9.&nbsp;Project dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>)
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>详细信息请参阅<a class="ulink" href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" target="_top"><code class="classname">ProjectDependency</code></a>的 API 文档 <br>For more information see the API documentation for <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" target="_top"><code class="classname">ProjectDependency</code></a></p>
     <p>多项目构建将在<a class="xref" href="multi_project_builds.html">第 56 章，<i>多项目生成</i></a>中进行详述。 <br>Multi-project builds are discussed in<a class="xref" href="multi_project_builds.html">Chapter&nbsp;56, <i>Multi-project Builds</i></a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:file_dependencies"></a>50.4.4. 文件依赖</h3>
        <h5 class="title"><a name="sub:file_dependencies"></a>50.4.4.&nbsp;File dependencies</h5>
       </div>
      </div>
     </div>
     <p>文件依赖允许你直接将一组文件添加到配置中，而不用先将它们添加到存储库。这将会非常有用，比如你无法，或者是不想要把某些文件放到仓库。或者是你如果不想使用任何仓库来存储你的依赖。 <br>File dependencies allow you to directly add a set of files to a configuration, without first adding them to a repository. This can be useful if you cannot, or do not want to, place certain files in a repository. Or if you do not want to use any repositories at all for storing your dependencies.</p>
     <p>如果想添加一些文件作为配置的依赖，你只需要传一个<a class="link" href="working_with_files.html#sec:file_collections">文件集合</a>作为依赖： <br>To add some files as a dependency for a configuration, you simply pass a <a class="link" href="working_with_files.html#sec:file_collections">file collection</a> as a dependency:</p>
     <div class="example">
      <a name="file-dependencies"></a>
      <p class="title"><b>示例 50.10. 文件依赖 - Example&nbsp;50.10.&nbsp;File dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime files(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs/a.jar'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs/b.jar'</span>)
    runtime fileTree(dir: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs'</span>, include: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'*.jar'</span>)
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>文件依赖项不会包含在你的项目的发布的依赖描述中。然而，文件依赖会被包含在同一个构建的传递项目依赖里。这意味着它们不能在当前的构建外使用，但它们可以在同一个构建中使用。 <br>File dependencies are not included in the published dependency descriptor for your project. However, file dependencies are included in transitive project dependencies within the same build. This means they cannot be used outside the current build, but they can be used with the same build.</p>
     <p> 你可以声明哪些任务将产生作为文件依赖的文件。例如，你可以在通过构建生成文件的时候这样做。 <br>You can declare which tasks produce the files for a file dependency. You might do this when, for example, the files are generated by the build.</p>
     <div class="example">
      <a name="generatedFileDependencies"></a>
      <p class="title"><b>示例 50.11. 生成文件依赖 - Example&nbsp;50.11.&nbsp;Generated file dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile files(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$buildDir/classes"</span>) {
        builtBy <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>
    }
}

task compile &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compiling classes'</span>
}

task list(dependsOn: configurations.compile) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"classpath = ${configurations.compile.collect {File file -&gt; file.name}}"</span>
}</pre>
       <p><strong class="userinput"><code>gradle -q list</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q list</code></strong></p>
       <pre class="screen">&gt; gradle -q list
compiling classes
classpath = [classes]</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:api_dependencies"></a>50.4.5. Gradle API 依赖</h3>
        <h5 class="title"><a name="sub:api_dependencies"></a>50.4.5.&nbsp;Gradle API Dependency</h5>
       </div>
      </div>
     </div>
     <p>你可以通过使用<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" target="_top"><code class="classname">DependencyHandler.gradleApi()</code></a>方法，来声明一个当前的 Gradle 版本的 API 上的依赖。当你在开发自定义 Gradle 任务或插件时将会很有用。 <br>You can declare a dependency on the API of the current version of Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" target="_top"><code class="classname">DependencyHandler.gradleApi()</code></a> method. This is useful when you are developing custom Gradle tasks or plugins.</p>
     <div class="example">
      <a name="gradle-api-dependencies"></a>
      <p class="title"><b>示例 50.12. Gradle API 依赖 - Example&nbsp;50.12.&nbsp;Gradle API dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile gradleApi()
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:groovy_dependencies"></a>50.4.6. 本地 Groovy 依赖</h3>
        <h5 class="title"><a name="sub:groovy_dependencies"></a>50.4.6.&nbsp;Local Groovy Dependency</h5>
       </div>
      </div>
     </div>
     <p>可以通过使用<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" target="_top"><code class="classname">DependencyHandler.localGroovy()</code></a>方法，来声明对与 Gradle 一起发布的 Groovy 的依赖。当你在开发自定义 Gradle 任务或在 Groovy 中的插件时将会很有用。 <br>You can declare a dependency on the Groovy that is distributed with Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" target="_top"><code class="classname">DependencyHandler.localGroovy()</code></a> method. This is useful when you are developing custom Gradle tasks or plugins in Groovy.</p>
     <div class="example">
      <a name="local-groovy-dependencies"></a>
      <p class="title"><b>示例 50.13. Gradle 的 Groovy 依赖 - Example&nbsp;50.13.&nbsp;Gradle's Groovy dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile localGroovy()
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:exclude_transitive_dependencies"></a>50.4.7. 排除传递依赖</h3>
        <h5 class="title"><a name="sub:exclude_transitive_dependencies"></a>50.4.7.&nbsp;Excluding transitive dependencies</h5>
       </div>
      </div>
     </div>
     <p>通过配置或者是通过依赖，你可以排除一个<span class="emphasis"><em>传递</em></span>依赖： <br>You can exclude a <span class="emphasis"><em>transitive</em></span> dependency either by configuration or by dependency:</p>
     <div class="example">
      <a name="exclude-dependencies"></a>
      <p class="title"><b>示例 50.14. 排除传递依赖 - Example&nbsp;50.14.&nbsp;Excluding transitive dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">configurations {
    compile.exclude module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'commons'</span>
    all*.exclude group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.test.excludes'</span>, module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'reports'</span>
}

dependencies {
    compile(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.test.excludes:api:1.0"</span>) {
        exclude module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'shared'</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>如果你为一个特定的配置定义一个 exclude，则解析此配置或任何继承的配置时，对于所有的依赖，所排除的传递依赖将会被过滤掉。如果你想要从你的所有配置中排除传递依赖，你可以用简明的方式，使用 Groovy 的 spread-dot 运算符来表示，如这个例子所示例。在定义一个 exclude 时，你可以只指定 organization 或者 module 名称，或者是两者都指定。可以看看 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/Dependency.html" target="_top"><code class="classname">Dependency</code></a> 和 <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a> 的 API 文档。 <br>If you define an exclude for a particular configuration, the excluded transitive dependency will be filtered for all dependencies when resolving this configuration or any inheriting configuration. If you want to exclude a transitive dependency from all your configurations you can use the Groovy spread-dot operator to express this in a concise way, as shown in the example. When defining an exclude, you can specify either only the organization or only the module name or both. Have also a look at the API documentation of <a class="ulink" href="../javadoc/org/gradle/api/artifacts/Dependency.html" target="_top"><code class="classname">Dependency</code></a> and <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.</p>
     <p> 不是每个传递依赖都可以被排除 — — 一些传递依赖可能是应用程序能正确运行的必要条件。一般来说，可以被排除的传递依赖，在运行时并不需要，或者是保证在目标环境或平台上可用。 <br>Not every transitive dependency can be excluded - some transitive dependencies might be essential for correct runtime behavior of the application. Generally, one can exclude transitive dependencies that are either not required by runtime or that are guaranteed to be available on the target environment/platform.</p>
     <p> 你应排除每个依赖或每个配置吗？事实证明，在大多数情况下你想要排除每一个配置。下面是为什么可能想要排除传递依赖的一些原因。记住，对于其中一些用例，有着比排除更好的解决方案！ <br>Should you exclude per-dependency or per-configuration? It turns out that in majority of cases you want to use the per-configuration exclusion. Here are the some exemplary reasons why one might want to exclude a transitive dependency. Bear in mind that for some of those use cases there are better solutions than exclusions!</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem">由于许可证的原因而让依赖不受欢迎。<br>The dependency is undesired due to licensing reasons.</li>
       <li class="listitem">在任何的远程仓库中这个依赖都不可用。<br>The dependency is not available in any of remote repositories.</li>
       <li class="listitem">在运行时不需要这个依赖。<br>The dependency is not needed for runtime.</li>
       <li class="listitem">这个依赖有一个版本与所需要的版本冲突。使用这个案例，请参考<a class="xref" href="dependency_management.html#sub:version_conflicts">第 50.2.3 节，“解决版本冲突”</a>和关于<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>文档，以了解这个问题潜在的更好的解决方案。 <br>The dependency has a version that conflicts with a desired version. For that use case please refer to <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;50.2.3, “Resolve version conflicts”</a> and the documentation on <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for a potentially better solution to the problem.</li>
      </ul>
     </div>
     <p> 基本上，在大多数情况下对每一个配置都是排除传递依赖。这种依赖声明的方式更加明确。它也更准确，因为每个依赖排除规则并不能保证给定的传递依赖不会显示在配置中。例如，某些其他的依赖，并没有任何排除规则，可能会带上那个多余的传递依赖。 <br>Basically, in most of the cases excluding the transitive dependency should be done per configuration. This way the dependency declaration is more explicit. It is also more accurate because a per-dependency exclude rule does not guarantee the given transitive dependency does not show up in the configuration. For example, some other dependency, which does not have any exclude rules, might pull in that unwanted transitive dependency.</p>
     <p> 其他相关依赖关系排除的示例，可以参考 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html" target="_top"> <code class="classname">ModuleDependency</code></a>或<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>。 <br>Other examples of the dependency exclusions can be found in the reference for <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html" target="_top"><code class="classname">ModuleDependency</code></a> or <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N14E4D"></a>50.4.8. 可选属性</h3>
        <h5 class="title"><a name="N14E4D"></a>50.4.8.&nbsp;Optional attributes</h5>
       </div>
      </div>
     </div>
     <p><a name="para:dependencies_with_empty_attributes"></a>一个依赖的所有属性都是可选的，除了 name。这取决于仓库类型，这些信息实际上需要用于在仓库中找到这个依赖。请参阅<a class="xref" href="dependency_management.html#sec:repositories"> 50.6 节，“仓库”</a>。例如，如果你使用 Maven 仓库，你需要定义group，name 和 version。如果你使用文件系统仓库，你可能只需要 name 或 name 和 version。 <br><a name="para:dependencies_with_empty_attributes"></a>All attributes for a dependency are optional, except the name. It depends on the repository type, which information is need for actually finding the dependencies in the repository. See <a class="xref" href="dependency_management.html#sec:repositories">Section&nbsp;50.6, “Repositories”</a>. If you work for example with Maven repositories, you need to define the group, name and version. If you work with filesystem repositories you might only need the name or the name and the version.</p>
     <div class="example">
      <a name="dependenciesWithEmptyAttributes"></a>
      <p class="title"><b>示例 50.15. 依赖的可选属性 - Example&nbsp;50.15.&nbsp;Optional attributes of dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":junit:4.10"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":testng"</span>
    runtime name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'testng'</span> 
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p><a name="para:notation_collections"></a>你也可以向一个配置指定依赖 notations 的集合或数组： <br><a name="para:notation_collections"></a>You can also assign collections or arrays of dependency notations to a configuration:</p>
     <div class="example">
      <a name="listGrouping"></a>
      <p class="title"><b>示例 50.16. 依赖的集合和数组 - Example&nbsp;50.16.&nbsp;Collections and arrays of dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">List groovy = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.codehaus.groovy:groovy-all:2.2.0@jar"</span>,
               <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"commons-cli:commons-cli:1.0@jar"</span>,
               <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant:1.9.3@jar"</span>]
List hibernate = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate:hibernate:3.0.5@jar'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'somegroup:someorg:1.0@jar'</span>]
dependencies {
    runtime groovy, hibernate
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:dependency_configurations"></a>50.4.9. 依赖配置</h3>
        <h5 class="title"><a name="sec:dependency_configurations"></a>50.4.9.&nbsp;Dependency configurations</h5>
       </div>
      </div>
     </div>
     <p>在 Gradle ，一个依赖可以有不同的配置 (就像你的项目可以有不同的配置)。如果你不显式指定任何东西，Gradle 会使用依赖的默认配置。对于 Maven 存储库的依赖，至少默认配置是唯一可用的一个。如果你使用 Ivy 存储库，并且想要为你的依赖定义一个非默认配置，就要使用 map 标记法并且声明： <br>In Gradle a dependency can have different configurations (as your project can have different configurations). If you don't specify anything explicitly, Gradle uses the default configuration of the dependency. For dependencies from a Maven repository, the default configuration is the only available one anyway. If you work with Ivy repositories and want to declare a non-default configuration for your dependency you have to use the map notation and declare:</p>
     <div class="example">
      <a name="dependencyConfigurations"></a>
      <p class="title"><b>示例 50.17. 依赖配置 - Example&nbsp;50.17.&nbsp;Dependency configurations</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.somegroup'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'somedependency'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'someConfiguration'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>同样的项目依赖，你需要声明：<br>To do the same for project dependencies you need to declare:</p>
     <div class="example">
      <a name="dependencyConfigurationsProjects"></a>
      <p class="title"><b>示例 50.18. 项目的依赖配置 - Example&nbsp;50.18.&nbsp;Dependency configurations for project</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile project(path: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spi'</span>)
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N14E89"></a>50.4.10.&nbsp;依赖报告</h3>
        <h5 class="title"><a name="N14E89"></a>50.4.10.&nbsp;Dependency reports</h5>
       </div>
      </div>
     </div>
     <p>你可以从命令行生成依赖报告 （参阅 <a class="xref" href="tutorial_gradle_command_line.html#para:commandline_dependency_report">第11.6.4节，“列出项目依赖”</a>）。通过使用 Project report 插件（参阅 <a class="xref" href="project_reports_plugin.html">第 41 章， <i>Project Report 插件</i></a>），在构建中可以创建一个这样的报告。 <br>You can generate dependency reports from the command line (see <a class="xref" href="tutorial_gradle_command_line.html#para:commandline_dependency_report">Section&nbsp;11.6.4, “Listing project dependencies”</a>). With the help of the Project report plugin (see <a class="xref" href="project_reports_plugin.html">Chapter&nbsp;41, <i>The Project Report Plugin</i></a>) such a report can be created by your build.</p>
     <p> 从 Gradle 1.2 起，有一个新的编程 API 用于访问解析的依赖信息。依赖报告（见前面一段）正是使用此 API。这个 API 可以让你查看解析的依赖图，并提供有关依赖的信息。在未来的版本，这个API 将提供更多有关解析结果的详细信息。关于这个 API 的更多信息，请参考 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult()" target="_top"><code class="classname">ResolvableDependencies.getResolutionResult()</code></a>上的文档。<a class="ulink" href="../javadoc/org/gradle/api/artifacts/result/ResolutionResult.html" target="_top"><code class="classname">ResolutionResult</code></a> API的可能用法： <br>Since Gradle 1.2 there is also a new programmatic API to access the resolved dependency information. The dependency reports (see the previous paragraph) are using this API under the covers. The API lets you to walk the resolved dependency graph and provides information about the dependencies. With the coming releases the API will grow to provide more information about the resolution result. For more information about the API please refer to the javadocs on <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult()" target="_top"><code class="classname">ResolvableDependencies.getResolutionResult()</code></a>. Potential usages of the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/result/ResolutionResult.html" target="_top"><code class="classname">ResolutionResult</code></a> API:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem">创建高级的依赖报告，以适应你的用例。<br>Creation of advanced dependency reports tailored to your use case.</li>
       <li class="listitem">启用使构建逻辑基于依赖树的内容来决定。<br>Enabling the build logic to make decisions based on the content of the dependency graph.</li>
      </ul>
     </div>
     <p> </p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:working_with_dependencies"></a>50.5.&nbsp;使用依赖</h2>
       <h4 class="title"><a name="sec:working_with_dependencies"></a>50.5.&nbsp;Working with dependencies</h4>
      </div>
     </div>
    </div>
    <p>下面的示例我们使用以下依赖设置：<br>For the examples below we have the following dependencies setup:</p>
    <div class="example">
     <a name="configurationHandlingSetup"></a>
     <p class="title"><b>示例 50.19. Configuration.copy - Example&nbsp;50.19.&nbsp;Configuration.copy</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">configurations {
    sealife
    alllife
}

dependencies {
    sealife <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.mammals:orca:1.0"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:shark:1.0"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:1.0"</span>
    alllife configurations.sealife
    alllife <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds:albatros:1.0"</span>
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p>这些依赖有以下的传递依赖：<br>The dependencies have the following transitive dependencies:</p>
    <p>shark-1.0 -&gt; seal-2.0, tuna-1.0</p>
    <p>orca-1.0 -&gt; seal-1.0</p>
    <p>tuna-1.0 -&gt; herring-1.0</p>
    <p>你可以使用配置来访问它们的声明依赖或其中一个子集： <br>You can use the configuration to access the declared dependencies or a subset of those:</p>
    <div class="example">
     <a name="configurationHandlingDependencies"></a>
     <p class="title"><b>示例 50.20. 访问声明依赖 - Example&nbsp;50.20.&nbsp;Accessing declared dependencies</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task dependencies &lt;&lt; {
    configurations.alllife.dependencies.each { dep -&gt; println dep.name }
    println()
    configurations.alllife.allDependencies.each { dep -&gt; println dep.name }
    println()
    configurations.alllife.allDependencies.findAll { dep -&gt; dep.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { dep -&gt; println dep.name }
}</pre>
      <p><strong class="userinput"><code>gradle -q dependencies</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q dependencies</code></strong></p>
      <pre class="screen">&gt; gradle -q dependencies
albatros

albatros
orca
shark
tuna

albatros
shark
tuna</pre>
     </div>
    </div>
    <br class="example-break">
    <p><code class="code">dependencies</code>返回只明确属于配置的依赖。<code class="code">allDependencies</code>包括了扩展配置的依赖。 <br><code class="code">dependencies</code> returns only the dependencies belonging explicitly to the configuration. <code class="code">allDependencies</code> includes the dependencies from extended configurations.</p>
    <p>要获得配置依赖的library文件，你可以这样： <br>To get the library files of the configuration dependencies you can do:</p>
    <div class="example">
     <a name="configurationHandlingAllFiles"></a>
     <p class="title"><b>示例 50.21. Configuration.files - Example&nbsp;50.21.&nbsp;Configuration.files</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task allFiles &lt;&lt; {
    configurations.sealife.files.each { file -&gt;
        println file.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q allFiles</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q allFiles</code></strong></p>
      <pre class="screen">&gt; gradle -q allFiles
orca-1.0.jar
shark-1.0.jar
tuna-1.0.jar
herring-1.0.jar
seal-2.0.jar</pre>
     </div>
    </div>
    <br class="example-break">
    <p>有时你想要配置依赖的某个子集（例如单个依赖）的 library 文件。 <br>Sometimes you want the library files of a subset of the configuration dependencies (e.g. of a single dependency).</p>
    <div class="example">
     <a name="configurationHandlingFiles"></a>
     <p class="title"><b>示例&nbsp;50.22.&nbsp;指定的 Configuration.files - Example&nbsp;50.22.&nbsp;Configuration.files with spec</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task files &lt;&lt; {
    configurations.sealife.files { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
        println file.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q files</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q files</code></strong></p>
      <pre class="screen">&gt; gradle -q files
orca-1.0.jar
seal-2.0.jar</pre>
     </div>
    </div>
    <br class="example-break">
    <p><code class="code">Configuration.files</code>方法总是获取<span class="emphasis"><em>整个</em></span>配置的所有 artifacts。然后，由指定的依赖筛选获取的文件。正如你在示例中所看到的，传递依赖都被包括在内。 <br>The <code class="code">Configuration.files</code> method always retrieves all artifacts of the <span class="emphasis"><em>whole</em></span> configuration. It then filters the retrieved files by specified dependencies. As you can see in the example, transitive dependencies are included.</p>
    <p>你还可以复制配置。你可以选择指定只复制原始配置里的一个子集的依赖。复制的方法有两种。<code class="code">copy</code>方法只复制明确属于配置的依赖。<code class="code">copyRecursive</code>方法将复制所有依赖，包括扩展配置的依赖。 <br>You can also copy a configuration. You can optionally specify that only a subset of dependencies from the original configuration should be copied. The copying methods come in two flavors. The <code class="code">copy</code> method copies only the dependencies belonging explicitly to the configuration. The <code class="code">copyRecursive</code> method copies all the dependencies, including the dependencies from extended configurations.</p>
    <div class="example">
     <a name="configurationHandlingCopy"></a>
     <p class="title"><b>示例 50.23. Configuration.copy - Example&nbsp;50.23.&nbsp;Configuration.copy</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task copy &lt;&lt; {
    configurations.alllife.copyRecursive { dep -&gt; dep.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.allDependencies.each { dep -&gt;
        println dep.name
    }
    println()
    configurations.alllife.copy().allDependencies.each { dep -&gt;
        println dep.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q copy</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p>
      <pre class="screen">&gt; gradle -q copy
albatros
shark
tuna

albatros</pre>
     </div>
    </div>
    <br class="example-break">
    <p>要重点注意，复制的配置所返回的文件，往往并不总是与原始配置的依赖子集所返回的文件一样。在子集的依赖和不属于子集的依赖之间，存在版本冲突的情况下，解析的结果可能会有所不同。 <br>It is important to note that the returned files of the copied configuration are often but not always the same than the returned files of the dependency subset of the original configuration. In case of version conflicts between dependencies of the subset and dependencies not belonging to the subset the resolve result might be different.</p>
    <div class="example">
     <a name="configurationHandlingCopyVsFiles"></a>
     <p class="title"><b>示例 50.24. Configuration.copy 与 Configuration.files - Example&nbsp;50.24.&nbsp;Configuration.copy vs. Configuration.files</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task copyVsFiles &lt;&lt; {
    configurations.sealife.copyRecursive { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
        println file.name
    }
    println()
    configurations.sealife.files { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
        println file.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q copyVsFiles</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q copyVsFiles</code></strong></p>
      <pre class="screen">&gt; gradle -q copyVsFiles
orca-1.0.jar
seal-1.0.jar

orca-1.0.jar
seal-2.0.jar</pre>
     </div>
    </div>
    <br class="example-break">
    <p>在上面的例子中 <code class="code">orca</code> 依赖 <code class="code">seal-1.0</code> 而 <code class="code">shark</code> 依赖于 <code class="code">seal-2.0</code>。原始配置因此有版本冲突，所以被解析为更新的 <code class="code">seal-2.0</code> 版本。<code class="code">files</code> 方法因此返回 <code class="code">seal-2.0</code> 作为 <code class="code">orca</code>的传递依赖。复制的配置只有 <code class="code">orca</code> 一个依赖，因此没有版本冲突，<code class="code">seal-1.0</code> 作为传递依赖被返回。 <br>In the example above, <code class="code">orca</code> has a dependency on <code class="code">seal-1.0</code> whereas <code class="code">shark</code> has a dependency on<code class="code">seal-2.0</code>. The original configuration has therefore a version conflict which is resolved to the newer <code class="code">seal-2.0</code> version. The <code class="code">files</code> method therefore returns <code class="code">seal-2.0</code> as a transitive dependency of<code class="code">orca</code>. The copied configuration only has <code class="code">orca</code> as a dependency and therefore there is no version conflict and <code class="code">seal-1.0</code> is returned as a transitive dependency.</p>
    <p>一旦一个配置被解析，那它就是不可变的了。如果去修改它的状态，或者是它的某个依赖的状态，将会引发一个异常。你可以永远复制一个解析了的配置。这个复制的配置处于未解析的状态，并且可以被刷新解析。 <br>Once a configuration is resolved it is immutable. Changing its state or the state of one of its dependencies will cause an exception. You can always copy a resolved configuration. The copied configuration is in the unresolved state and can be freshly resolved.</p>
    <p>想了解更多关于这个配置类的API，可以参阅它的 API 文档：<a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>. <br>To learn more about the API of the configuration class see the API documentation: <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:repositories"></a>50.6. 仓库</h2>
       <h4 class="title"><a name="sec:repositories"></a>50.6.&nbsp;Repositories</h4>
      </div>
     </div>
    </div>
    <p>Gradle 仓库管理，基于 Apache Ivy，为你提供了有关仓库布局和获取策略的许多自由。另外，Gradle 提供了各种方便的方法来添加预配置的仓库。 <br>Gradle repository management, based on Apache Ivy, gives you a lot of freedom regarding repository layout and retrieval policies. Additionally Gradle provides various convenience method to add pre-configured repositories.</p>
    <p>您可以配置任意数量的仓库，每一个都会被Gradle 独立处理。如果 Gradle 在特定仓库中查找模块描述符，它将尝试从<span class="emphasis"><em>同一仓库中</em></span>下载该模块的所有 artifacts。虽然模块的元数据和模块 artifacts 必须位于同一仓库，但也有可能单个仓库有多个 Url，给多个位置去搜索元数据文件和 jar 文件。 <br>You may configure any number of repositories, each of which is treated independently by Gradle. If Gradle finds a module descriptor in a particular repository, it will attempt to download all of the artifacts for that module from <span class="emphasis"><em>the same repository</em></span>. Although module meta-data and module artifacts must be located in the same repository, it is possible to compose a single repository of multiple URLs, giving multiple locations to search for meta-data files and jar files.</p>
    <p>有几种不同类型的存储库可以声明：<br>There are several different types of repositories you can declare:</p>
    <div xmlns:xslthl="http://xslthl.sf.net" class="table">
     <p class="title"><b>表 50.2. 仓库类型 - Table&nbsp;50.2.&nbsp;Repository types</b></p>
     <div class="table-contents">
      <table id="N14F63">
       <thead>
        <tr> 
         <td>类型<br>Type</td> 
         <td>描述<br>Description</td> 
        </tr>
       </thead>
       <tbody>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_central">Maven 中央仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_central">Maven central repository</a></td> 
         <td>一个会在 Maven 中央仓中查找依赖的预配置仓库。<br>A pre-configured repository that looks for dependencies in Maven Central.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_jcenter">Maven JCenter 仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_jcenter">Maven JCenter repository</a></td> 
         <td>一个会在 Bintray 的 Jcenter 查找依赖的预配置仓库。<br>A pre-configured repository that looks for dependencies in Bintray's JCenter.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_local">Maven 本地仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_local">Maven local repository</a></td> 
         <td>一个会在本地 Maven 仓库中查找依赖的预配置仓库。<br>A pre-configured repository that looks for dependencies in the local Maven repository.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_repo">Maven 仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_repo">Maven repository</a></td> 
         <td>一个 Maven 仓库。可以位于本地文件系统上，或在某个远程的位置。<br>A Maven repository. Can be located on the local filesystem or at some remote location.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sec:ivy_repositories">Ivy 仓库</a> <br><a class="link" href="dependency_management.html#sec:ivy_repositories">Ivy repository</a></td> 
         <td>一个 Ivy 仓库可以位于本地文件系统上，或在某个远程的位置。<br>An Ivy repository. Can be located on the local filesystem or at some remote location.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sec:flat_dir_resolver">Flat 目录仓库</a> <br><a class="link" href="dependency_management.html#sec:flat_dir_resolver">Flat directory repository</a></td> 
         <td>一个在本地文件系统上的简单的仓库。不支持任何元数据格式。<br>A simple repository on the local filesystem. Does not support any meta-data formats.</td> 
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_central"></a>50.6.1. Maven 中央仓库</h3>
        <h5 class="title"><a name="sub:maven_central"></a>50.6.1.&nbsp;Maven central repository</h5>
       </div>
      </div>
     </div>
     <p>若要添加中央 Maven 2 仓库（<a class="ulink" href="http://repo1.maven.org/maven2" target="_top">http://repo1.maven.org/maven2</a>），只需添加下面的代码到你的构建脚本中： <br>To add the central Maven 2 repository (<a class="ulink" href="http://repo1.maven.org/maven2" target="_top">http://repo1.maven.org/maven2</a>) simply add this to your build script:</p>
     <div class="example">
      <a name="mavenCentral"></a>
      <p class="title"><b>示例 50.25. 添加 Maven 中央仓库 - Example&nbsp;50.25.&nbsp;Adding central Maven repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    mavenCentral()
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>现在 Gradle 将会在此仓库中查找你的依赖。 <br>Now Gradle will look for your dependencies in this repository.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_jcenter"></a>50.6.2. Maven JCenter 仓库</h3>
        <h5 class="title"><a name="sub:maven_jcenter"></a>50.6.2.&nbsp;Maven JCenter repository</h5>
       </div>
      </div>
     </div>
     <p><a class="ulink" href="http://bintray.com" target="_top">Bintray</a>JCenter 是所有流行的 Maven OSS artifacts 的up-to-date 集合，包括直接发布到 Bintray 的 artifacts。 <br><a class="ulink" href="http://bintray.com" target="_top">Bintray</a>'s JCenter is an up-to-date collection of all popular Maven OSS artifacts, including artifacts published directly to Bintray.</p>
     <p>若要添加 JCenter Maven 仓库（<a class="ulink" href="http://jcenter.bintray.com" target="_top">http://jcenter.bintray.com</a>），只需添加下面的内容到你的构建脚本中： <br>To add the JCenter Maven repository (<a class="ulink" href="http://jcenter.bintray.com" target="_top">http://jcenter.bintray.com</a>) simply add this to your build script:</p>
     <div class="example">
      <a name="mavenJcenter"></a>
      <p class="title"><b>示例 50.26. 添加 Bintray Jcenter Maven 仓库 - Example&nbsp;50.26.&nbsp;Adding Bintray's JCenter Maven repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    jcenter()
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>现在 Gradle 将会在 JCenter 仓库中查找你的依赖。 <br>Now Gradle will look for your dependencies in the JCenter repository.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_local"></a>50.6.3. 本地 Maven 仓库</h3>
        <h5 class="title"><a name="sub:maven_local"></a>50.6.3.&nbsp;Local Maven repository</h5>
       </div>
      </div>
     </div>
     <p>你可以这样把本地的 Maven 缓存作为仓库使用：<br>To use the local Maven cache as a repository you can do:</p>
     <div class="example">
      <a name="mavenLocalRepo"></a>
      <p class="title"><b>示例 50.27. 添加本地 Maven 缓存作为仓库： - Example&nbsp;50.27.&nbsp;Adding the local Maven cache as a repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    mavenLocal()
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>Gradle 使用与 Maven 相同的逻辑来标识你本地的 Maven 缓存的位置。如果在<code class="filename">settings.xml</code>中定义一个本地仓库的位置，那么这个位置将会被使用。在<code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2</code> 的<code class="filename">settings.xml</code> 比在 <code class="filename"> <em class="replaceable"> <code>M2_HOME</code></em>/conf</code>的<code class="filename">settings.xml</code>优先。如果没有<code class="filename">settings.xml</code>可用，Gradle 将使用默认的位置<code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2/repository</code>。 <br>Gradle uses the same logic as Maven to identify the location of your local Maven cache. If a local repository location is defined in a <code class="filename">settings.xml</code>, this location will be used. The <code class="filename">settings.xml</code> in <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2</code> takes precedence over the <code class="filename">settings.xml</code> in <code class="filename"><em class="replaceable"><code>M2_HOME</code></em>/conf</code>. If no <code class="filename">settings.xml</code> is available, Gradle uses the default location <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2/repository</code>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_repo"></a>50.6.4. Maven 仓库</h3>
        <h5 class="title"><a name="sub:maven_repo"></a>50.6.4.&nbsp;Maven repositories</h5>
       </div>
      </div>
     </div>
     <p>要添加一个自定义的 Maven 仓库，你可以如下操作： <br>For adding a custom Maven repository you can do:</p>
     <div class="example">
      <a name="mavenLikeRepo"></a>
      <p class="title"><b>示例 50.28. 添加一个自定义的 Maven 仓库 - Example&nbsp;50.28.&nbsp;Adding custom Maven repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>有时候，一个仓库会出现 POM 文件发布在一个地方，而 JAR 文件和其他构件发布在另一个地方。要定义一个这样的仓库，你可以这样： <br>Sometimes a repository will have the POMs published to one location, and the JARs and other artifacts published at another location. To define such a repository, you can do:</p>
     <div class="example">
      <a name="mavenLikeRepoWithJarRepo"></a>
      <p class="title"><b>示例 50.29. 为 JAR 文件添加额外的 Maven 仓库 - Example&nbsp;50.29.&nbsp;Adding additional Maven repositories for JAR files</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    maven {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Look for POMs and artifacts, such as JARs, here</span>
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo2.mycompany.com/maven2"</span>
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Look for artifacts here if not found at the above location</span>
        artifactUrls <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/jars"</span>
        artifactUrls <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/jars2"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>Gradle 将会在第一个URL中查找 POM 和 JAR 文件。如果那里找不到 JAR，就会用 artifact URLs 来查找 JAR 文件。 <br>Gradle will look at the first URL for the POM and the JAR. If the JAR can't be found there, the artifact URLs are used to look for JARs.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N15031"></a>50.6.4.1. 访问密码保护的 Maven 仓库</h4>
         <h6 class="title"><a name="N15031"></a>50.6.4.1.&nbsp;Accessing password protected Maven repositories</h6>
        </div>
       </div>
      </div>
      <p>要访问一个使用基本的身份验证的 Maven 仓库，当你在定义该仓库时要指定使用的用户名和密码： <br>To access a Maven repository which uses basic authentication, you specify the username and password to use when you define the repository:</p>
      <div class="example">
       <a name="mavenPasswordProtectedRepo"></a>
       <p class="title"><b>示例 50.30. 访问密码保护的 Maven 仓库 - Example&nbsp;50.30.&nbsp;Accessing password protected Maven repository</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    maven {
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
      <p>最好是把你的用户名和密码写在<code class="filename">gradle.properties</code>中，而不是直接写在构建文件中。 <br>It is advisable to keep your username and password in <code class="filename">gradle.properties</code> rather than directly in the build file.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:flat_dir_resolver"></a>50.6.5. 平面的目录仓库</h3>
        <h5 class="title"><a name="sec:flat_dir_resolver"></a>50.6.5.&nbsp;Flat directory repository</h5>
       </div>
      </div>
     </div>
     <p>如果你想要把一个（平面）文件系统目录作为仓库使用，只需输入： <br>If you want to use a (flat) filesystem directory as a repository, simply type:</p>
     <div class="example">
      <a name="flatDirMulti"></a>
      <p class="title"><b>示例 50.31. 平面仓库的解决 - Example&nbsp;50.31.&nbsp;Flat repository resolver</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    flatDir {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
    }
    flatDir {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib1'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib2'</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>这将会添加一些用于查找依赖的仓库，它会在一个或多个目录中寻找。如果你只使用平面目录解析器，那么你不需要去设置一个依赖的所有属性。请参阅<a class="xref" href="dependency_management.html#para:dependencies_with_empty_attributes"> 第50.4.8 节，“可选属性”</a> <br>This adds repositories which look into one or more directories for finding dependencies. If you only work with flat directory resolvers you don't need to set all attributes of a dependency. See <a class="xref" href="dependency_management.html#para:dependencies_with_empty_attributes">Section&nbsp;50.4.8, “Optional attributes”</a></p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:ivy_repositories"></a>50.6.6. Ivy 存储库</h3>
        <h5 class="title"><a name="sec:ivy_repositories"></a>50.6.6.&nbsp;Ivy repositories</h5>
       </div>
      </div>
     </div>
     <p>使用一个标准布局的 Ivy 存储库：<br>To use an Ivy repository with a standard layout:</p>
     <div class="example">
      <a name="ivyRepository"></a>
      <p class="title"><b>示例 50.32. Ivy存储库 - Example&nbsp;50.32.&nbsp;Ivy repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"maven"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>详细信息请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html" target="_top"><code class="classname">IvyArtifactRepository</code> </a> 。 <br>See <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html" target="_top"><code class="classname">IvyArtifactRepository</code></a> for details.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N15071"></a>50.6.6.1. 为一个 Ivy 存储库定义自定义的模式</h4>
         <h6 class="title"><a name="N15071"></a>50.6.6.1.&nbsp;Defining custom patterns for an Ivy repository</h6>
        </div>
       </div>
      </div>
      <p>若要定义非标准布局的 Ivy 仓库，你可以定义一个仓库模式布局： <br>To define an Ivy repository with a non-standard layout, you can define a pattern layout for the repository:</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例 50.33. Ivy 仓库模式布局 - Example&nbsp;50.33.&nbsp;Ivy repository with pattern layout</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"[module]/[revision]/[type]/[artifact].[ext]"</span>
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N15080"></a>50.6.6.2.&nbsp;使用 Maven 兼容布局的 Ivy 仓库</h4>
         <h6 class="title"><a name="N15080"></a>50.6.6.2.&nbsp;Ivy repository with Maven compatible layout</h6>
        </div>
       </div>
      </div>
      <p>作为可选的功能，一个使用模式布局的仓库可以有它自己的以Maven 风格奠定的“组织”部分，该部分使用斜杠替换点作为分隔符。例如，组织<code class="literal">my.company</code>将表示为<code class="literal">my/company</code>。 <br>Optionally, a repository with pattern layout can have its 'organisation' part laid out in Maven style, with forward slashes replacing dots as separators. For example, the organisation <code class="literal">my.company</code> would then be represented as <code class="literal">my/company</code>.</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例50.34.&nbsp;使用 Maven 兼容布局的 Ivy 仓库 - Example&nbsp;50.34.&nbsp;Ivy repository with Maven compatible layout</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            m2compatible = true
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N15095"></a>50.6.6.3. 为一个 Ivy 仓库定义不同的 artifact 和 Ivy 文件位置</h4>
         <h6 class="title"><a name="N15095"></a>50.6.6.3.&nbsp;Defining different artifact and Ivy file locations for an Ivy repository</h6>
        </div>
       </div>
      </div>
      <p>若要定义一个从不同的位置获取 Ivy 文件和 artifacts 的 Ivy 仓库，您可以使用模式布局，每个单独的模式用于定位到 Ivy 文件和 artifacts： <br>To define an Ivy repository which fetches Ivy files and artifacts from different locations, you can use the pattern layout with separate patterns to use to locate the Ivy files and artifacts:</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例 50.35. 自定义模式的 Ivy 仓库 - Example&nbsp;50.35.&nbsp;Ivy repository with custom patterns</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            ivy <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ivy-files/[organisation]/[module]/[revision]/ivy.xml"</span>
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
      <p> 每个<code class="literal">artifact</code>或<code class="literal">ivy</code>都指定了一个仓库，添加一个<span class="emphasis"><em>额外的</em></span>的模式来使用。这些模式以定义它们的顺序来使用。 <br>Each <code class="literal">artifact</code> or <code class="literal">ivy</code> specified for a repository adds an <span class="emphasis"><em>additional</em></span> pattern to use. The patterns are used in the order that they are defined.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N150AF"></a>50.6.6.4. 访问密码保护的 Ivy 仓库</h4>
         <h6 class="title"><a name="N150AF"></a>50.6.6.4.&nbsp;Accessing password protected Ivy repositories</h6>
        </div>
       </div>
      </div>
      <p>要访问一个使用基本的身份验证的 Ivy 仓库，当你在定义该仓库时要指定使用的用户名和密码： <br>To access an Ivy repository which uses basic authentication, you specify the username and password to use when you define the repository:</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例 50.36. Ivy存储库 - Example&nbsp;50.36.&nbsp;Ivy repository</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'http://repo.mycompany.com'</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N150BE"></a>50.6.7.&nbsp;使用仓库</h3>
        <h5 class="title"><a name="N150BE"></a>50.6.7.&nbsp;Working with repositories</h5>
       </div>
      </div>
     </div>
     <p>若要访问一个仓库：<br>To access a repository:</p>
     <div class="example">
      <a name="defineRepository"></a>
      <p class="title"><b>示例 50.37. 访问一个仓库： - Example&nbsp;50.37.&nbsp;Accessing a repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">println repositories.localRepository.name
    println repositories[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'localRepository'</span>].name</pre>
      </div>
     </div>
     <br class="example-break">
     <p>要配置一个仓库：<br>To configure a repository:</p>
     <div class="example">
      <a name="defineRepository"></a>
      <p class="title"><b>示例 50.38. 仓库配置 - Example&nbsp;50.38.&nbsp;Configuration of a repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    flatDir {
        name <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'localRepository'</span>
    }
}
repositories {
    localRepository {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
    }
}
repositories.localRepository {
    dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:more_about_ivy_resolvers"></a>50.6.8. 更多关于 Ivy 解析器的信息</h3>
        <h5 class="title"><a name="sub:more_about_ivy_resolvers"></a>50.6.8.&nbsp;More about Ivy resolvers</h5>
       </div>
      </div>
     </div>
     <p>Gradle由于 Ivy 在它的 hood 之下，对仓库非常灵活。 <br>Gradle, thanks to Ivy under its hood, is extremely flexible regarding repositories:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"><p>对于与仓库通信的协议，有很多的选项（比如文件系统，http， ssh……） </p><br><p>There are many options for the protocol to communicate with the repository (e.g. filesystem, http, ssh, ...) </p></li>
       <li class="listitem"><p>每个仓库都可以有其自己的布局。 </p><br><p>Each repository can have its own layout. </p></li>
      </ul>
     </div>
     <p>比方说，你可以声明一个<code class="literal">junit:junit:3.8.2</code>库的依赖。现在 Gradle 是如何发现它在存储库中的?某种程度上依赖信息必须映射到一个路径上。相比于固定路径的 Maven，使用 Gradle 你可以定义一个模式，该模式定义了路径的样子。这里有一些例子：<sup>[<a href="#ftn.N150EB" name="N150EB" class="footnote">16</a>]</sup> <br>Let's say, you declare a dependency on the <code class="literal">junit:junit:3.8.2</code> library. Now how does Gradle find it in the repositories? Somehow the dependency information has to be mapped to a path. In contrast to Maven, where this path is fixed, with Gradle you can define a pattern that defines what the path will look like. Here are some examples: <sup>[<a href="#ftn.N150EB" name="N150EB" class="footnote">16</a>]</sup></p>
     <pre class="programlisting">// Maven2 layout (if a repository is marked as Maven2 compatible, the organization (group) is split into subfolders according to the dots.)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// Typical layout for an Ivy repository (the organization is not split into subfolder)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// Simple layout (the organization is not used, no nested folders.)
someroot/[artifact]-[revision].[ext]</pre>
     <p>要添加任何一种仓库 (你可以很简单地编写你自己的) ，你可以： <br>To add any kind of repository (you can pretty easy write your own ones) you can do:</p>
     <div class="example">
      <a name="fileSystemResolver"></a>
      <p class="title"><b>示例 50.39. 自定义仓库的定义 - Example&nbsp;50.39.&nbsp;Definition of a custom repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    ivy {
        ivyPattern <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$projectDir/repo/[organisation]/[module]-ivy-[revision].xml"</span>
        artifactPattern <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$projectDir/repo/[organisation]/[module]-[revision](-[classifier]).[ext]"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>其中由 Ivy （也因此由 Gradle ）提供解析器的，它的概述可以在<a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" target="_top">这里</a>找到。通过Gradle，你只是不用通过XML来配置它们，而是通过它们的API。 <br>An overview of which Resolvers are offered by Ivy and thus also by Gradle can be found <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" target="_top">here</a>. With Gradle you just don't configure them via XML but directly via their API.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependency_resolution"></a>50.7. 依赖解析的工作原理</h2>
       <h4 class="title"><a name="sec:dependency_resolution"></a>50.7.&nbsp;How dependency resolution works</h4>
      </div>
     </div>
    </div>
    <p>Gradle 将获取你的依赖声明和仓库定义，并通过一个称为<span class="emphasis"><em>依赖项解析</em></span>的过程尝试下载所有依赖项。下面是这个过程的工作原理的简要概述。 <br>Gradle takes your dependency declarations and repository definitions and attempts to download all of your dependencies by a process called <span class="emphasis"><em>dependency resolution</em></span>. Below is a brief outline of how this process works.</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p> 给出所需的依赖项，Gradle 首先尝试为该依赖解析<span class="emphasis"><em>模块</em></span>。每个仓库按顺序进行检查，首先查找指示该模块存在的<span class="emphasis"><em>模块描述符</em></span>文件（POM 或 Ivy 文件）。如果没有找到模块描述符，Gradle 将搜索表示模块存在于存储库中的主要<span class="emphasis"><em>模块 artifact</em></span>文件。 </p>
       <div class="itemizedlist">
        <ul class="itemizedlist">
         <li class="listitem"><p>如果依赖被声明为一个动态版本（像<code class="literal">1.+</code>），Gradle 将会把它解析到在仓库中的最新的可用的静态版本（如<code class="literal">1.2</code>）。对于 Maven 仓库，是通过<code class="literal">maven metadata.xml</code>文件来实现，而对于 Ivy 存储库，则是通过目录列表。 </p></li>
         <li class="listitem"><p>如果模块描述符是一个具有的父 POM 文件声明的 POM 文件，Gradle 将以递归方式尝试为该 POM 文件解析每个父模块。 </p></li>
        </ul>
       </div><br><p> Given a required dependency, Gradle first attempts to resolve the <span class="emphasis"><em>module</em></span> for that dependency. Each repository is inspected in order, searching first for a <span class="emphasis"><em>module descriptor</em></span> file (POM or Ivy file) that indicates the presence of that module. If no module descriptor is found, Gradle will search for the presence of the primary <span class="emphasis"><em>module artifact</em></span> file indicating that the module exists in the repository. </p> 
       <div class="itemizedlist"> 
        <ul class="itemizedlist"> 
         <li class="listitem"><p>If the dependency is declared as a dynamic version (like <code class="literal">1.+</code>), Gradle will resolve this to the newest available static version (like <code class="literal">1.2</code>) in the repository. For Maven repositories, this is done using the <code class="literal">maven-metadata.xml</code> file, while for Ivy repositories this is done by directory listing. </p></li> 
         <li class="listitem"><p>If the module descriptor is a POM file that has a parent POM declared, Gradle will recursively attempt to resolve each of the parent modules for the POM. </p></li> 
        </ul> 
       </div></li>
      <li class="listitem"><p>一旦已为该模块检查了每个仓库，Gradle 将会选择使用“最好”的一个。它使用以下标准来完成： </p>
       <div class="itemizedlist">
        <ul class="itemizedlist">
         <li class="listitem">对于动态版本，“高”的静态版本优于“低”的版本。</li>
         <li class="listitem">由模块描述符文件（Ivy或 POM 文件）声明的文件优于只有一个artifact 文件的模块。</li>
         <li class="listitem">前面的仓库的模块优于后面的仓库的模块。</li>
        </ul>
       </div><p> </p><p>当依赖由一个静态版本来声明，并且在仓库中找到模块描述符文件时，将不会再继续搜索后面的仓库，这个过程的其余部分是短路的。 </p><br><p>Once each repository has been inspected for the module, Gradle will choose the 'best' one to use. This is done using the following criteria: </p> 
       <div class="itemizedlist"> 
        <ul class="itemizedlist"> 
         <li class="listitem">For a dynamic version, a 'higher' static version is preferred over a 'lower' version.</li> 
         <li class="listitem">Modules declared by a module descriptor file (Ivy or POM file) are preferred over modules that have an artifact file only.</li> 
         <li class="listitem">Modules from earlier repositories are preferred over modules in later repositories.</li> 
        </ul> 
       </div><p> </p><p>When the dependency is declared by a static version and a module descriptor file is found in a repository, there is no need to continue searching later repositories and the remainder of the process is short-circuited. </p></li>
      <li class="listitem"><p>然后这个模块的所有artifact将从上面的过程所选择的 <span class="emphasis"><em>同一个仓库</em></span> 中请求。 </p><br><p>All of the artifacts for the module are then requested from the <span class="emphasis"><em>same repository</em></span> that was chosen in the process above. </p></li>
     </ul>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N1513F"></a>50.8. 微调依赖解析过程</h2>
       <h4 class="title"><a name="N1513F"></a>50.8.&nbsp;Fine-tuning the dependency resolution process</h4>
      </div>
     </div>
    </div>
    <p>在大多数情况下，Gradle 的默认依赖管理将会在你的构建中按你所想的解析依赖关系。然而，在某些情况下，会有必要调整依赖解析，以确保你的构建能得到正确的依赖关系。 <br>In most cases, Gradle's default dependency management will resolve the dependencies that you want in your build. In some cases, however, it can be necessary to tweak dependency resolution to ensure that your build receives exactly the right dependencies.</p>
    <p>有许多种方式都可以影响到Gradle解析依赖。<br>There are a number of ways that you can influence how Gradle resolves dependencies.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:forcing_modules"></a>50.8.1.&nbsp;强制一个特定模块的版本</h3>
        <h5 class="title"><a name="sec:forcing_modules"></a>50.8.1.&nbsp;Forcing a particular module version</h5>
       </div>
      </div>
     </div>
     <p>强制一个模块的版本，是告诉 Gradle 对于指定的依赖（不管是否传递依赖），始终使用一个特定的版本，而覆盖在发布的模块描述符中所指定的任何版本。当解决版本冲突时，这可能非常有用——有关详细信息请参阅<a class="xref" href="dependency_management.html#sub:version_conflicts">第 50.2.3 节，“解决版本冲突”</a>。 <br>Forcing a module version tells Gradle to always use a specific version for given dependency (transitive or not), overriding any version specified in a published module descriptor. This can be very useful when tackling version conflicts - for more information see <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;50.2.3, “Resolve version conflicts”</a>.</p>
     <p> 强制版本也可以用于处理传递依赖所带来的流氓元数据。如果传递依赖有质量较差的元数据，导致了依赖解析时的问题时，你可以强制 Gradle 对于这一依赖使用一个较新的，固定的版本。有关示例，请参见<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>。请注意，“依赖解析规则”（见下文），提供了一种更强大的机制，来取代一个损坏的模块依赖。请参阅<a class="xref" href="dependency_management.html#sec:blacklisting_version">50.8.2.3 节，“黑名单替换指定版本”</a>。 <br>Force versions can also be used to deal with rogue metadata of transitive dependencies. If a transitive dependency has poor quality metadata that leads to problems at dependency resolution time, you can force Gradle to use a newer, fixed version of this dependency. For an example, see <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>. Note that 'dependency resolve rules' (outlined below) provide a more powerful mechanism for replacing a broken module dependency. See <a class="xref" href="dependency_management.html#sec:blacklisting_version">Section&nbsp;50.8.2.3, “Blacklisting a particular version with a replacement”</a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:dependency_resolve_rules"></a>50.8.2. 使用依赖解析规则</h3>
        <h5 class="title"><a name="sec:dependency_resolve_rules"></a>50.8.2.&nbsp;Using dependency resolve rules</h5>
       </div>
      </div>
     </div>
     <p>一个依赖解析规则为每一个解析依赖执行，并提供功能强大的 api 用于在解析依赖之前处理这个依赖的请求。此功能还在<a class="link" href="feature_lifecycle.html">孵化中</a>，但目前提供了对于一个请求的依赖更改组、 名称及版本的功能，允许在解析过程中，把一个依赖替换为另一个完全不同的模块。 <br>A dependency resolve rule is executed for each resolved dependency, and offers a powerful api for manipulating a requested dependency prior to that dependency being resolved. This feature is <a class="link" href="feature_lifecycle.html">incubating</a>, but currently offers the ability to change the group, name and/or version of a requested dependency, allowing a dependency to be substituted with a completely different module during resolution.</p>
     <p> 依赖解析规则提供了一种非常强大的方式来控制依赖解析过程，并可以用于实现在依赖管理中各种高级模式的排序。下面将概述其中的某些模式。更多的信息和代码示例请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>。 <br>Dependency resolve rules provide a very powerful way to control the dependency resolution process, and can be used to implement all sorts of advanced patterns in dependency management. Some of these patterns are outlined below. For more information and code samples see <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:releasable_unit"></a>50.8.2.1.&nbsp;模块化可发布的单位</h4>
         <h6 class="title"><a name="sec:releasable_unit"></a>50.8.2.1.&nbsp;Modelling releaseable units</h6>
        </div>
       </div>
      </div>
      <p>通常一个组织会使用一个版本发布一组库；这些库将在一起构建，测试以及发布。这些库形成一个“可发布的单位”，被设计并打算作为一个整体使用。而一起使用来自不同的可发布单位的库，也不会有意义。 <br>Often an organisation publishes a set of libraries with a single version; where the libraries are built, tested and published together. These libraries form a 'releasable unit', designed and intended to be used as a whole. It does not make sense to use libraries from different releasable units together.</p>
      <p> 但传递依赖解析会很容易破坏这种协议。举个例子： <br>But it is easy for transitive dependency resolution to violate this contract. For example:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem"><code class="literal">module-a</code> 依赖于 <code class="literal">releasable-unit:part-one:1.0</code><br><code class="literal">module-a</code> depends on <code class="literal">releasable-unit:part-one:1.0</code></li>
        <li class="listitem"><code class="literal">module-a</code> 依赖于 <code class="literal">releasable-unit:part-one:1.0</code><br><code class="literal">module-b</code> depends on <code class="literal">releasable-unit:part-two:1.1</code></li>
       </ul>
      </div>
      <p> 一个依赖于<code class="literal">module-a</code>和<code class="literal">module-b</code>的构建，将在可发布单位内获得这个库的不同版本。 <br>A build depending on both <code class="literal">module-a</code> and <code class="literal">module-b</code> will obtain different versions of libraries within the releasable unit.</p>
      <p> 依赖解析规则使你能够在构建中强制指定可发布的单位。想象一下，一个可发布的单位，由有“org.gradle” 组的所有库定义。我们可以强制所有这些库使用一致的版本： <br>Dependency resolve rules give you the power to enforce releasable units in your build. Imagine a releasable unit defined by all libraries that have 'org.gradle' group. We can force all of these libraries to use a consistent version:</p>
      <div class="example">
       <a name="releasable-unit"></a>
       <p class="title"><b>示例 50.40. 强制一个组的所有库使用一致的版本 - Example&nbsp;50.40.&nbsp;Forcing consistent version for a group of libraries</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle'</span>) {
            details.useVersion <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.4'</span>
        }
    }
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:custom_versioning_scheme"></a>50.8.2.2.&nbsp;实现一个自定义的版本方案</h4>
         <h6 class="title"><a name="sec:custom_versioning_scheme"></a>50.8.2.2.&nbsp;Implement a custom versioning scheme</h6>
        </div>
       </div>
      </div>
      <p> 在一些企业的环境中，可以声明在 gradle 构建中的模块版本列表，是在外部维护和审核的。依赖解析规则提供了这种模式的整洁的实现： <br>In some corporate environments, the list of module versions that can be declared in gradle builds is maintained and audited externally. Dependency resolve rules provide a neat implementation of this pattern:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">在构建脚本中，开发人员使用模块组与名称声明依赖，但使用占位符版本，例如：“<code class="literal">default</code>”。<br>In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: '<code class="literal">default</code>'.</li>
        <li class="listitem">这个“default”版本通过一个依赖解析规则被解析为一个特定的版本，这个规则将在一个核准模块的公司中查找该版本。<br>The 'default' version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.</li>
       </ul>
      </div>
      <p> 该规则实现可以整齐地封装在一个公司的插件中，并在组织内和所有构建共享。 <br>This rule implementation can be neatly encapsulated in a corporate plugin, and shared across all builds within the organisation.</p>
      <div class="example">
       <a name="custom-versioning-scheme"></a>
       <p class="title"><b>示例 50.41. 使用自定义的版本方案 - Example&nbsp;50.41.&nbsp;Using a custom versioning scheme</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'default'</span>) {
            def version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
            details.useVersion version
        }
    }
}

def findDefaultVersionInCatalog(String group, String name) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//some custom logic that resolves the default version into a specific version</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.0"</span>
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:blacklisting_version"></a>50.8.2.3. 黑名单替换特定版本</h4>
         <h6 class="title"><a name="sec:blacklisting_version"></a>50.8.2.3.&nbsp;Blacklisting a particular version with a replacement</h6>
        </div>
       </div>
      </div>
      <p> 依赖解析规则提供了一个机制，用于把一个依赖的指定版本列入黑名单，并提供一个替代的版本。如果某个依赖的版本坏了，并且不应该被使用，这个机制将非常有用。一个依赖解析规则将会使这个版本被替换为一个已知的好的版本。一个坏的模块的例子是，在一个库上声明的一个依赖无法在任何公共仓库中找到，但为什么不能使用一个特定的模块版本，而更希望要另一个版本，还有很多其他原因。 <br>Dependency resolve rules provide a mechanism for blacklisting a particular version of a dependency and providing a replacement version. This can be useful if a certain dependency version is broken and should not be used, where a dependency resolve rule causes this version to be replaced with a known good version. One example of a broken module is one that declares a dependency on a library that cannot be found in any of the public repositories, but there are many other reasons why a particular module version is unwanted and a different version is preferred.</p>
      <p> 在下面的示例中，想象版本<code class="literal">1.2.1</code>包含了重要的修复程序，并应始终优先于<code class="literal">1.2</code>使用。提供的规则将强制执行：在任何时间遇到了<code class="literal">1.2</code>版本，都将会替换为<code class="literal">1.2.1</code>。注意，这与上面描述的强制使用一个版本不同，这个模块的其他版本将不受影响。这意味着，如果这个版本也因依赖传递被获取到，“使用最新”的冲突解决策略仍然会选择 <code class="literal">1.3</code> 版本。 <br>In example below, imagine that version <code class="literal">1.2.1</code> contains important fixes and should always be used in preference to <code class="literal">1.2</code>. The rule provided will enforce just this: any time version <code class="literal">1.2</code> is encountered it will be replaced with <code class="literal">1.2.1</code>. Note that this is different from a forced version as described above, in that any other versions of this module would not be affected. This means that the 'newest' conflict resolution strategy would still select version <code class="literal">1.3</code> if this version was also pulled transitively.</p>
      <div class="example">
       <a name="blacklisting_version"></a>
       <p class="title"><b>示例 50.42. 黑名单替换特定版本 - Example&nbsp;50.42.&nbsp;Blacklisting a version with a replacement</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.software'</span> &amp;&amp; details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'some-library'</span> &amp;&amp; details.requested.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.2'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer different version which contains some necessary fixes</span>
            details.useVersion <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.2.1'</span>
        }
    }
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:module_substitution"></a>50.8.2.4. 使用一个兼容模块替换一个依赖模块</h4>
         <h6 class="title"><a name="sec:module_substitution"></a>50.8.2.4.&nbsp;Substituting a dependency module with a compatible replacement</h6>
        </div>
       </div>
      </div>
      <p>有时一个完全不同的模块可以作为请求的模块依赖的替代者。示例包括，使用“<code class="literal">groovy</code>”来代替“<code class="literal">groovy-all</code>”，或者使用“<code class="literal">log4j-over-slf4j</code>”来代替“<code class="literal">log4j</code>”。从 Gradle 1.5 开始，你可以使用依赖解析规则来进行这些替换： <br>At times a completely different module can serve as a replacement for a requested module dependency. Examples include using '<code class="literal">groovy</code>' in place of '<code class="literal">groovy-all</code>', or using '<code class="literal">log4j-over-slf4j</code>' instead of '<code class="literal">log4j</code>'. Starting with Gradle 1.5 you can make these substitutions using dependency resolve rules:</p>
      <div class="example">
       <a name="module_substitution"></a>
       <p class="title"><b>示例 50.43. 在解析中更改依赖组及名称 - Example&nbsp;50.43.&nbsp;Changing dependency group and/or name at the resolution</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy-all'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer 'groovy' over 'groovy-all':</span>
            details.useTarget group: details.requested.group, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy'</span>, version: details.requested.version
        }
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'log4j'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer 'log4j-over-slf4j' over 'log4j', with fixed version:</span>
            details.useTarget <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.slf4j:log4j-over-slf4j:1.7.5"</span>
        }
    }
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="ivy_dynamic_resolve_mode"></a>50.8.3.&nbsp;启用 Ivy 动态解析模式</h3>
        <h5 class="title"><a name="ivy_dynamic_resolve_mode"></a>50.8.3.&nbsp;Enabling Ivy dynamic resolve mode</h5>
       </div>
      </div>
     </div>
     <p> Gradle 的Ivy 仓库实现支持相当于 Ivy 的动态解析的模式。通常情况下，Gradle 将<code class="literal">rev</code>属性用于在<code class="filename">ivy.xml</code>文件中包含的每个依赖定义。在动态解析模式中，Gradle 将优先使用<code class="literal">revConstraint</code>属性来代替<code class="literal">rev</code>属性，用于一个给定的依赖定义。如果不存在<code class="literal">revConstraint</code>属性，则使用<code class="literal">rev</code>属性。 <br>Gradle's Ivy repository implementations support the equivalent to Ivy's dynamic resolve mode. Normally, Gradle will use the <code class="literal">rev</code> attribute for each dependency definition included in an <code class="filename">ivy.xml</code> file. In dynamic resolve mode, Gradle will instead prefer the <code class="literal">revConstraint</code> attribute over the <code class="literal">rev</code> attribute for a given dependency definition. If the <code class="literal">revConstraint</code> attribute is not present, the <code class="literal">rev</code> attribute is used instead.</p>
     <p>若要启用动态解析模式，你需要在仓库定义进行合适的设置。下面展示了几个例子。注意，动态解析模式只对 Gradle 的 Ivy 仓库有效。它不能用于 Maven 仓库，或自定义的 Ivy <code class="classname">DependencyResolver</code>实现。<br>To enable dynamic resolve mode, you need to set the appropriate option on the repository definition. A couple of examples are shown below. Note that dynamic resolve mode is only available for Gradle's Ivy repositories. It is not available for Maven repositories, or custom Ivy <code class="classname">DependencyResolver</code> implementations.</p>
     <div class="example">
      <a name="dynamicResolveMode"></a>
      <p class="title"><b>示例 50.44.&nbsp;启用动态解析模式 - Example&nbsp;50.44.&nbsp;Enabling dynamic resolve mode</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Can enable dynamic resolve mode when you define the repository</span>
repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        resolve.dynamicMode = true
    }
}

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories</span>
repositories.withType(IvyArtifactRepository) {
    resolve.dynamicMode = true
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="component_metadata_rules"></a>50.8.4. 组件元数据规则</h3>
        <h5 class="title"><a name="component_metadata_rules"></a>50.8.4.&nbsp;Component metadata rules</h5>
       </div>
      </div>
     </div>
     <p>每个模块（也称为<span class="emphasis"><em>组件</em></span>）都有相关的元数据上，像它的组，名称，版本，依赖，等等。这个元数据通常来源于模块的描述符。元数据规则允许模块的元数据在构建脚本中被操纵。它们在模块描述符下载之后，被所有候选版本之间选择之前生效。这使得元数据成为自定义依赖解析的另一种手段。 <br>Each module (also called <span class="emphasis"><em>component</em></span>) has metadata associated with it, such as its group, name, version, dependencies, and so on. This metadata typically originates in the module's descriptor. Metadata rules allow certain parts of a module's metadata to be manipulated from within the build script. They take effect after a module's descriptor has been downloaded, but before it has been selected among all candidate versions. This makes metadata rules another instrument for customizing dependency resolution.</p>
     <p> 其中一个 Gradle 能理解的模块元数据是模块的<span class="emphasis"><em>状态模式</em></span>。这一概念，也可以从 Ivy 中，随着时间推移，一个模块发展的成熟水平可以得知。默认状态模式，按状态的成熟程度排序，分别是<code class="literal">integration</code>、<code class="literal">milestone</code>、<code class="literal">release</code>。除了状态模式以外，模块也有一个（当前） 的<span class="emphasis"><em>状态</em></span>，这个状态必须是它的状态模式中的值之一。如果没有在（Ivy）描述符中指定，Ivy 模块和 Maven snapshot模块的状态默认为<code class="literal">integration</code> ，不是snapshot 的 Maven 模块则默认为<code class="literal">release</code>。 <br>One piece of module metadata that Gradle understands is a module's <span class="emphasis"><em>status scheme</em></span>. This concept, also known from Ivy, models the different levels of maturity that a module transitions through over time. The default status scheme, ordered from least to most mature status, is <code class="literal">integration</code>, <code class="literal">milestone</code>, <code class="literal">release</code>. Apart from a status scheme, a module also has a (current) <span class="emphasis"><em>status</em></span>, which must be one of the values in its status scheme. If not specified in the (Ivy) descriptor, the status defaults to <code class="literal">integration</code> for Ivy modules and Maven snapshot modules, and <code class="literal">release</code> for Maven modules that aren't snapshots.</p>
     <p> 一个模块的状态以及状态模式，会在解析 <code class="literal">latest</code> 版本选择器时考虑到。具体而言，<code class="literal">latest.someStatus</code> 将会解析成有着<code class="literal">someStatus</code> 或更成熟状态的最高的模块版本。例如，在适当的位置使用默认的状态模式，<code class="literal">latest.integration</code>将选择最高的模块版本，不论其状态（因为<code class="literal">integration</code>是成熟度最低的状态），而<code class="literal">latest.release</code>将选择<code class="literal">release</code>状态的最高模块版本。这里是在代码中的表现： <br>A module's status and status scheme are taken into consideration when a <code class="literal">latest</code> version selector is resolved. Specifically, <code class="literal">latest.someStatus</code> will resolve to the highest module version that has status <code class="literal">someStatus</code> or a more mature status. For example, with the default status scheme in place, <code class="literal">latest.integration</code> will select the highest module version regardless of its status (because <code class="literal">integration</code> is the least mature status), whereas <code class="literal">latest.release</code> will select the highest module version with status <code class="literal">release</code>. Here is what this looks like in code:</p>
     <div class="example">
      <a name="latestSelector"></a>
      <p class="title"><b>示例&nbsp;50.45，“Latest”版本选择器 - Example&nbsp;50.45.&nbsp;'Latest' version selector</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    config1 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:latest.integration"</span>
    config2 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:latest.release"</span>
}

task listFish &lt;&lt; {
    configurations.config1.each { println it.name }
    println()
    configurations.config2.each { println it.name}
}</pre>
       <p><strong class="userinput"><code>gradle -q listFish</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q listFish</code></strong></p>
       <pre class="screen">&gt; gradle -q listFish
tuna-1.5.jar

tuna-1.4.jar</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 下一个示例演示了基于在一个模块的元数据规则中声明的自定义状态模式的<code class="literal">latest</code>选择器： <br>The next example demonstrates <code class="literal">latest</code> selectors based on a custom status scheme declared in a module metadata rule:</p>
     <div class="example">
      <a name="customStatusScheme"></a>
      <p class="title"><b>示例 50.46. 自定义状态模式 - Example&nbsp;50.46.&nbsp;Custom status scheme</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    config3 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds:albatros:latest.silver"</span>
    components {
        eachComponent { ComponentMetadataDetails details -&gt;
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.id.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds"</span>) {
                details.statusScheme = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"bronze"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"silver"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"gold"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"platinum"</span>]
            }
        }
    }
}

task listBirds &lt;&lt; {
    configurations.config3.each { println it.name }
}</pre>
       <p><strong class="userinput"><code>gradle -q listBirds</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q listBirds</code></strong></p>
       <pre class="screen">&gt; gradle -q listBirds
albatros-2.0.jar</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependency_cache"></a>50.9. 依赖缓存</h2>
       <h4 class="title"><a name="sec:dependency_cache"></a>50.9.&nbsp;The dependency cache</h4>
      </div>
     </div>
    </div>
    <p>Gradle 包含了一个高度复杂的依赖缓存机制，该机制力求减少依赖解析中的远程请求，同时努力保证依赖解析结果的正确及可再生性。 <br>Gradle contains a highly sophisticated dependency caching mechanism, which seeks to minimise the number of remote requests made in dependency resolution, while striving to guarantee that the results of dependency resolution are correct and reproducible.</p>
    <p> Gradle 依赖缓存包含 2 个主要类型的存储： <br>The Gradle dependency cache consists of 2 key types of storage:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p>一个基于文件的下载构件存储，包括像jars这样的二进制文件，以及像 POM 文件以及 Ivy 文件这样的原始下载的元数据。下载的构件的存储路径包括了 SHA1 校验和，意味着 2 个具有相同名称但内容不同的构件可以很容易地被缓存。 </p><br><p>A file-based store of downloaded artifacts, including binaries like jars as well as raw downloaded meta-data like POM files and Ivy files. The storage path for a downloaded artifact includes the SHA1 checksum, meaning that 2 artifacts with the same name but different content can easily be cached. </p></li>
      <li class="listitem"><p>解析的模块元数据的二进制存储，包括解析动态版本、 模块描述符和构件的结果。</p><br><p>A binary store of resolved module meta-data, including the results of resolving dynamic versions, module descriptors, and artifacts.</p></li>
     </ul>
    </div>
    <p>从下载的构件的存储中分享出缓存的元数据，将允许我们使用缓存做一些非常有用的东西，而如果使用一个透明的只有文件的缓存布局则会很困难。 <br>Separating the storage of downloaded artifacts from the cache metadata permits us to do some very powerful things with our cache that would be difficult with a transparent, file-only cache layout.</p>
    <p>Gradle 缓存中不允许本地缓存隐藏问题和，以及一直是许多构建工具的挑战的创造神秘及难以调试的行为。这一新行为通过带宽和存储空间的有效途径被实现。在此过程中，Gradle 实现了可靠和可重复的的企业构建。 <br>The Gradle cache does not allow the local cache to hide problems and creating mysterious and difficult to debug behavior that has been a challenge with many build tools. This new behavior is implemented in a bandwidth and storage efficient way. In doing so, Gradle enables reliable and reproducible enterprise builds.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:cache_features"></a>50.9.1. Gradle 依赖缓存的主要特点</h3>
        <h5 class="title"><a name="sec:cache_features"></a>50.9.1.&nbsp;Key features of the Gradle dependency cache</h5>
       </div>
      </div>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_metadata"></a>50.9.1.1. 单独的元数据缓存</h4>
         <h6 class="title"><a name="sub:cache_metadata"></a>50.9.1.1.&nbsp;Separate metadata cache</h6>
        </div>
       </div>
      </div>
      <p> Gradle 以二进制格式在元数据缓存中保留了依赖解析的各方面的记录。存储在元数据缓存中的信息包括： <br>Gradle keeps a record of various aspects of dependency resolution in binary format in the metadata cache. The information stored in the metadata cache includes:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">解析一个动态版本（例如<code class="literal">1.+</code>）到一个具体的版本（例如<code class="literal">1.2</code>）的结果。<br>The result of resolving a dynamic version (e.g. <code class="literal">1.+</code>) to a concrete version (e.g. <code class="literal">1.2</code>).</li>
        <li class="listitem">对于特定模块的解析后的模块元数据，包括模块构件和模块依赖。<br>The resolved module metadata for a particular module, including module artifacts and module dependencies.</li>
        <li class="listitem">对于特定构件的解析后的构件元数据，包括指向下载的构件工件的信息。<br>The resolved artifact metadata for a particular artifact, including a pointer to the downloaded artifact file.</li>
        <li class="listitem">在特定的仓库中<span class="emphasis"><em>缺少的</em></span>特定模块或工件，避免反复地尝试访问不存在的资源。 <br>The <span class="emphasis"><em>absence</em></span> of a particular module or artifact in a particular repository, eliminating repeated attempts to access a resource that does not exist.</li>
       </ul>
      </div>
      <p> 每个元数据缓存中的条目包括了一条存储库中提供的信息，以及可用于缓存到期的时间戳的记录。 <br>Every entry in the metadata cache includes a record of the repository that provided the information as well as a timestamp that can be used for cache expiry.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_repository_independence"></a>50.9.1.2.&nbsp;仓库缓存是独立的</h4>
         <h6 class="title"><a name="sub:cache_repository_independence"></a>50.9.1.2.&nbsp;Repository caches are independent</h6>
        </div>
       </div>
      </div>
      <p>如上文所述，每个仓库是一个单独的元数据缓存。一个仓库由它的 URL、类型和布局来区分。如果一个模块或构件以之前没有从<span class="emphasis"><em>这个存储库中</em></span>解析过，Gradle 将尝试在这个存储库中解析这个模块。这将始终涉及到存储库中的远程查找，然而，在许多情况下都没有下载的需要（见<a class="xref" href="dependency_management.html#sub:cache_artifact_reuse">第 50.9.1.3 节，“构件重用”</a>下文）、。 <br>As described above, for each repository there is a separate metadata cache. A repository is identified by its URL, type and layout. If a module or artifact has not been previously resolved from <span class="emphasis"><em>this repository</em></span>, Gradle will attempt to resolve the module against the repository. This will always involve a remote lookup on the repository, however in many cases no download will be required (see<a class="xref" href="dependency_management.html#sub:cache_artifact_reuse">Section&nbsp;50.9.1.3, “Artifact reuse”</a>, below).</p>
      <p>如果所需的构件，在构建所指定的任何仓库中都没有找到的话，依赖解析将会失败，无论本地缓存是否从一个其他的仓库中取回这个构件。仓库独立允许构建之间用一种先进方法的方法彼此隔离，以前没有构建工具能做到这样。这是一个关键的功能，能在任何环境中创建可靠，重复性好的构建。 <br>Dependency resolution will fail if the required artifacts are not available in any repository specified by the build, regardless whether the local cache has retrieved this artifact from a different repository. Repository independence allows builds to be isolated from each other in an advanced way that no build tool has done before. This is a key feature to create builds that are reliable and reproducible in any environment.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_artifact_reuse"></a>50.9.1.3. 构件重用</h4>
         <h6 class="title"><a name="sub:cache_artifact_reuse"></a>50.9.1.3.&nbsp;Artifact reuse</h6>
        </div>
       </div>
      </div>
      <p>在下载构件前，Gradle 试图通过下载与该项目关联的sha文件以确定所需的构件的校验和。如果校验和可以获取到，并且如果已经存在具有相同 id 和校验和的构件，则不会再去下载这个构件。如果校验和不能从远程服务器检索，构件将被下载（并且忽略它所匹配的现有的构件）。 <br>Before downloading an artifact, Gradle tries to determine the checksum of the required artifact by downloading the sha file associated with that artifact. If the checksum can be retrieved, an artifact is not downloaded if an artifact already exists with the same id and checksum. If the checksum cannot be retrieved from the remote server, the artifact will be downloaded (and ignored if it matches an existing artifact).</p>
      <p>同时考虑构件从不同的仓库下载，Gradle 还将试图重用本地 Maven 库中发现的构件。如果一个候选的构件已经通过 Maven 下载，并且如果它可以和远程服务器定义的校验和匹配，Gradle 将使用这个构件。 <br>As well as considering artifacts downloaded from a different repository, Gradle will also attempt to reuse artifacts found in the local Maven Repository. If a candidate artifact has been downloaded by Maven, Gradle will use this artifact if it can be verified to match the checksum declared by the remote server.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_checksum_storage"></a>50.9.1.4.&nbsp;基于校验和的存储</h4>
         <h6 class="title"><a name="sub:cache_checksum_storage"></a>50.9.1.4.&nbsp;Checksum based storage</h6>
        </div>
       </div>
      </div>
      <p> 不同的仓库提供不同的二进制构件以响应相同的构件标识符是可能的。这种常见的情况是 Maven 的快照构件，但任何构件也都可以不改变它的标识符而重新发布。通过基于其 SHA1 校验和缓存构件，Gradle 是能够保持同一构件的多个版本。这意味着，当对一个存储库解析时，Gradle 将永远不会覆盖从一个不同的仓库中缓存的构件文件。这不需要让一个单独的文件在每一个仓库中存储就可以做到。 <br>It is possible for different repositories to provide a different binary artifact in response to the same artifact identifier. This is often the case with Maven SNAPSHOT artifacts, but can also be true for any artifact which is republished without changing it's identifier. By caching artifacts based on their SHA1 checksum, Gradle is able to maintain multiple versions of the same artifact. This means that when resolving against one repository Gradle will never overwrite the cached artifact file from a different repository. This is done without requiring a separate artifact file store per repository.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_locking"></a>50.9.1.5. 缓存锁</h4>
         <h6 class="title"><a name="sub:cache_locking"></a>50.9.1.5.&nbsp;Cache Locking</h6>
        </div>
       </div>
      </div>
      <p> Gradle 依赖缓存使用基于文件的锁来确保，它可以安全地通过多个 Gradle 进程并行使用。每当二进制元数据存储区正在读取或写入时，锁都会被持有，但会在慢的操作比如下载远程工作时释放。 <br>The Gradle dependency cache uses file-based locking to ensure that it can safely be used by multiple Gradle processes concurrently. The lock is held whenever the binary meta-data store is being read or written, but is released for slow operations such as downloading remote artifacts.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:cache_command_line_options"></a>50.9.2.&nbsp;重写缓存的命令行选项</h3>
        <h5 class="title"><a name="sec:cache_command_line_options"></a>50.9.2.&nbsp;Command line options to override caching</h5>
       </div>
      </div>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_offline"></a>50.9.2.1.&nbsp;离线</h4>
         <h6 class="title"><a name="sub:cache_offline"></a>50.9.2.1.&nbsp;Offline</h6>
        </div>
       </div>
      </div>
      <p><code class="literal">--offline</code> 命令行开机告诉 Gradle 总是从缓存中使用依赖模块，无论它们是否被再次检查。在使用离线运行时，Gradle 将不会尝试访问网络来执行依赖解析。如果所需的模块在依赖缓存中不存在，构建执行将会失败。 <br>The <code class="literal">--offline</code> command line switch tells Gradle to always use dependency modules from the cache, regardless if they are due to be checked again. When running with offline, Gradle will never attempt to access the network to perform dependency resolution. If required modules are not present in the dependency cache, build execution will fail.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_refresh"></a>50.9.2.2.&nbsp;刷新</h4>
         <h6 class="title"><a name="sub:cache_refresh"></a>50.9.2.2.&nbsp;Refresh</h6>
        </div>
       </div>
      </div>
      <p>有时，Gradle 依赖缓存可能与已配置的仓库的实际状态不同步。也许一个存储库的最初配置不正确，或许是一个“无改变”的模块被不正确地发布。要刷新依赖缓存中的所有依赖项，请使用<code class="literal">--refresh-dependencies</code>命令行选项。 <br>At times, the Gradle Dependency Cache can be out of sync with the actual state of the configured repositories. Perhaps a repository was initially misconfigured, or perhaps a "non-changing" module was published incorrectly. To refresh all dependencies in the dependency cache, use the <code class="literal">--refresh-dependencies</code> option on the command line.</p>
      <p><code class="literal">--refresh-dependencies</code> 选项告诉 Gradle 在解析模块和构件时忽略所有缓存条目。对所有已配置的仓库执行新的解析，通过重新计算动态版本，模块刷新，以及下载构件。然而，在再次下载之前Gradle 可能将会检查前一个下载的构件是否有效。这是通过比较发布在仓库中的 SHA1 值和现在已经下载好的工件的 SHA1 值来完成的。 <br>The <code class="literal">--refresh-dependencies</code> option tells Gradle to ignore all cached entries for resolved modules and artifacts. A fresh resolve will be performed against all configured repositories, with dynamic versions recalculated, modules refreshed, and artifacts downloaded. However, where possible Gradle will check if the previously downloaded artifacts are valid before downloading again. This is done by comparing published SHA1 values in the repository with the SHA1 values for existing downloaded artifacts.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:controlling_caching"></a>50.9.3. 依赖缓存的微调控制</h3>
        <h5 class="title"><a name="sec:controlling_caching"></a>50.9.3.&nbsp;Fine-tuned control over dependency caching</h5>
       </div>
      </div>
     </div>
     <p>你可以在一个配置中通过使用<code class="literal">ResolutionStrategy</code>对缓存的某些方面进行微调。 <br>You can fine-tune certain aspects of caching using the <code class="literal">ResolutionStrategy</code> for a configuration.</p>
     <p>默认情况下，Gradle 缓存动态版本的时间为 24 小时。如果要改变Gradle对解析一个动态版本的缓存时间，可以使用： <br>By default, Gradle caches dynamic versions for 24 hours. To change how long Gradle will cache the resolved version for a dynamic version, use:</p>
     <div class="example">
      <a name="dynamic-version-cache-control"></a>
      <p class="title"><b>示例 50.47. 动态版本缓存控制 - Example&nbsp;50.47.&nbsp;Dynamic version cache control</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">10</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'minutes'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>默认情况下，Gradle 的变化模块将缓存 24 小时。要修改 Gradle 对变化模块的元数据和构件的缓存时间，请使用： <br>By default, Gradle caches changing modules for 24 hours. To change how long Gradle will cache the meta-data and artifacts for a changing module, use:</p>
     <div class="example">
      <a name="changing-module-cache-control"></a>
      <p class="title"><b>示例 50.48. 变化模块的缓存控制 - Example&nbsp;50.48.&nbsp;Changing module cache control</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">configurations.all {
    resolutionStrategy.cacheChangingModulesFor <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hours'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>更多详细信息请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>的 API 文档。 <br>For more details, take a look at the API documentation for<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:strategies_of_transitive_dependency_management"></a>50.10. 传递依赖管理的策略</h2>
       <h4 class="title"><a name="sec:strategies_of_transitive_dependency_management"></a>50.10.&nbsp;Strategies for transitive dependency management</h4>
      </div>
     </div>
    </div>
    <p>许多项目依赖于<a class="ulink" href="http://repo1.maven.org/maven2" target="_top">Maven 中央仓库</a>。这不是没有问题的。 <br>Many projects rely on the <a class="ulink" href="http://repo1.maven.org/maven2" target="_top">Maven Central repository</a>. This is not without problems.</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p>Maven 中央存储库可能会下线，或者响应时间很长。 </p><br><p>The Maven Central repository can be down or has a very long response time. </p></li>
      <li class="listitem"><p>许多项目的 POM 文件会有错误的信息（比如，<code class="literal">commons-httpclient-3.0</code>的POM文件声明了 JUnit 是运行时依赖）。 </p><br><p>The POM files of many projects have wrong information (as one example, the POM of <code class="literal">commons-httpclient-3.0</code> declares JUnit as a runtime dependency). </p></li>
      <li class="listitem"><p>对于许多项目而言，可能不是只有正确的一组依赖（因POM格式的影响会多或少）。 </p><br><p>For many projects there is not one right set of dependencies (as more or less imposed by the POM format). </p></li>
     </ul>
    </div>
    <p>如果您的项目依赖于 Maven 中央仓，你很可能需要额外的自定义仓库，因为： <br>If your project relies on the Maven Central repository you are likely to need an additional custom repository, because:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p>你可能需要还没有上传到Maven 中央仓的依赖。 </p><br><p>You might need dependencies that are not uploaded to Maven Central yet. </p></li>
      <li class="listitem"><p>你想要正确地处理 Maven 中央仓 POM 文件中错误的元数据。 </p><br><p>You want to deal properly with wrong metadata in a Maven Central POM file. </p></li>
      <li class="listitem"><p>你不想曝光给想要对你的项目进行构建的人，Maven 中央仓停机或者有时候响应时间太长。 </p><br><p>You don't want to expose people who want to build your project, to the downtimes or sometimes very long response times of Maven Central. </p></li>
     </ul>
    </div>
    <p>想在设置一个自定义的仓库并不算什么。<sup>[<a href="#ftn.N15329" name="N15329" class="footnote">17</a>]</sup>但想让这个仓库保持最新的状态，可能会很乏味。对一个新的版本，你总是要创建新的 XML 描述符和目录。你的自定义存仓库是另一个基础结构元素，它可能有停机时间并且需要更新。要启用历史版本，你需要保留所有过去的库，并且需要备份。它是一个间接层。你还要查找另外一个信息源。尽管这一切真的不是大问题，但累加起来就有影响了。仓库管理器，比如像 Artifactory 或 Nexus 则会使这些工作变得轻松。但是比如开源项目通常没有主机用于这些产品。这种状况通过一些新的服务也改变了，比如<a class="ulink" href="http://bintray.com" target="_top">Bintray</a> ，它可以让开发者使用自助服务的仓库平台托管和分发他们发布的二进制文件。Bintray 还支持共享经过他们审核的构件，通过<a class="ulink" href="http://jcenter.bintray.com" target="_top">JCenter</a>公共仓库，为所有普通的OSS java 构件提供一个单一的解析地址（见<a class="xref" href="dependency_management.html#sub:maven_jcenter">第 50.6.2 节，“Maven JCenter 存储库”</a>）。 <br>It is not a big deal to set-up a custom repository. <sup>[<a href="#ftn.N15329" name="N15329" class="footnote">17</a>]</sup> But it can be tedious, to keep it up to date. For a new version, you have always to create the new XML descriptor and the directories. And your custom repository is another infrastructure element which might have downtimes and needs to be updated. To enable historical builds, you need to keep all the past libraries and you need a backup. It is another layer of indirection. Another source of information you have to lookup. All this is not really a big deal but in its sum it has an impact. Repository Manager like Artifactory or Nexus make this easier. But for example open source projects don't usually have a host for those products. This is changing with new services like <a class="ulink" href="http://bintray.com" target="_top">Bintray</a> that let developers host and distribute their release binaries using a self-service repository platform. Bintray also supports sharing approved artifacts though the <a class="ulink" href="http://jcenter.bintray.com" target="_top">JCenter</a> public repository to provide a single resolution address for all popular OSS java artifacts (see <a class="xref" href="dependency_management.html#sub:maven_jcenter">Section&nbsp;50.6.2, “Maven JCenter repository”</a>).</p>
    <p>这也是为什么一些项目更愿意把他们的库存储于他们的版本控件系统的原因。这种做法 Gradle 也完全支持。库可以存在一个平面目录中，而没有任何 XML 模块描述符文件。然而 Gradle 能提供完整的传递依赖管理。您可以使用客户端模块依赖，或者是工件依赖来表达依赖关系，后者的情况中第一级依赖是没有传递依赖的。人们可以从 svn 检出这样一个项目，并且具体必要的一切，来构建它。 <br>This is a reason why some projects prefer to store their libraries in their version control system. This approach is fully supported by Gradle. The libraries can be stored in a flat directory without any XML module descriptor files. Yet Gradle offers complete transitive dependency management. You can use either client module dependencies to express the dependency relations, or artifact dependencies in case a first level dependency has no transitive dependencies. People can check out such a project from svn and have everything necessary to build it.</p>
    <p>如果您是使用像 Git 一样的分布式版本控制系统，由于人们会检出整个历史，你可能不想使用版本控制系统来保存这些库。但即使是这样， Gradle 的灵活性也可以使你的生活更轻松。例如你可以使用一个共享平面目录，而不包括如上所述可以有完全的传递依赖管理的XML 描述符。 <br>If you are working with a distributed version control system like Git you probably don't want to use the version control system to store libraries as people check out the whole history. But even here the flexibility of Gradle can make your life easier. For example you can use a shared flat directory without XML descriptors and yet you can have full transitive dependency management as described above.</p>
    <p>你也可以使用混合策略。如果你主要关心的是 POM 文件和维护的自定义 XML 描述符中的元数据不正确，<span class="emphasis"><em>客户端模块</em></span>提供了一种替代方案。但你当然也可以仍然使用 Maven2 仓库和你自定义的存储库，作为<span class="emphasis"><em>只放 jars</em></span>和依然使用<span class="emphasis"><em>传递</em></span>依赖管理的仓库。或者，你可以只为元数字不正确的 POMs 提供客户端模块。对于这些jar 和不正确的 POMs，你依然要使用远程仓库。 <br>You could also have a mixed strategy. If your main concern is bad metadata in the POM file and maintaining custom XML descriptors, <span class="emphasis"><em>Client Modules</em></span> offer an alternative. But you can of course still use Maven2 repo and your custom repository as a repository for <span class="emphasis"><em>jars only</em></span> and still enjoy <span class="emphasis"><em>transitive</em></span> dependency management. Or you can only provide client modules for POMs with bad metadata. For the jars and the correct POMs you still use the remote repository.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:implicit_transitive_dependencies"></a>50.10.1. 隐式传递依赖</h3>
        <h5 class="title"><a name="sub:implicit_transitive_dependencies"></a>50.10.1.&nbsp;Implicit transitive dependencies</h5>
       </div>
      </div>
     </div>
     <p>还有另外一种方法，用于处理<span class="emphasis"><em>没有</em></span>XML 描述符文件的传递依赖。你可以使用 Gradle 来做，但我们不推荐它。我们提到它是为了完整性，以及和其他构建工具进行比较。 <br>There is another way to deal with transitive dependencies <span class="emphasis"><em>without</em></span> XML descriptor files. You can do this with Gradle, but we don't recommend it. We mention it for the sake of completeness and comparison with other build tools.</p>
     <p>诀窍是只使用构件依赖，并在列表中对它们进行分组。对于这种方法，你将用某种方式表达，你第一级的依赖项和传递依赖是什么（见<a class="xref" href="dependency_management.html#para:notation_collections">第 50.4.8 条，“可选属性”</a>）。但缺点是，对于 Gradle 依赖管理而言，所有的依赖都被认为是第一级依赖。依赖报告不会显示你真正的依赖关系图，并且<code class="literal">compile</code>任务会使用所有的依赖，而不只是第一级依赖。总之，比起使用客户端模块，你的构建不再那么容易维护和可靠。而你不会有其他收获。 <br>The trick is to use only artifact dependencies and group them in lists. That way you have somehow expressed, what are your first level dependencies and what are transitive dependencies (see <a class="xref" href="dependency_management.html#para:notation_collections">Section&nbsp;50.4.8, “Optional attributes”</a>). But the draw-back is, that for the Gradle dependency management all dependencies are considered first level dependencies. The dependency reports don't show your real dependency graph and the <code class="literal">compile</code> task uses all dependencies, not just the first level dependencies. All in all, your build is less maintainable and reliable than it could be when using client modules. And you don't gain anything.</p>
    </div>
   </div>
   <div class="footnotes">
    <br>
    <hr align="left" width="100">
    <div class="footnote">
     <p><sup>[<a href="#N14D3A" name="ftn.N14D3A" class="para">14</a>] </sup>Gradle 支持部分多项目构建（参见 <a class="xref" href="multi_project_builds.html">第 56 章， <i>多项目构建</i></a>）。<br><sup>[<a href="#N14D3A" name="ftn.N14D3A" class="para">14</a>] </sup>Gradle supports partial multiproject builds (see <a class="xref" href="multi_project_builds.html">Chapter&nbsp;56, <i>Multi-project Builds</i></a>).</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N14D58" name="ftn.N14D58" class="para">15</a>] </sup> <a class="ulink" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html" target="_top">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html</a> </p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N150EB" name="ftn.N150EB" class="para">16</a>] </sup>在<a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/concept.html" target="_top">http://ant.apache.org/ivy/history/latest-milestone/concept.html</a>，你可以了解到更多关于 ivy 模式的内容。 <br><sup>[<a href="#N150EB" name="ftn.N150EB" class="para">16</a>] </sup>At <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/concept.html" target="_top">http://ant.apache.org/ivy/history/latest-milestone/concept.html</a> you can learn more about ivy patterns.</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N15329" name="ftn.N15329" class="para">17</a>] </sup>如果你想要从 Maven 中央仓库停机保护你的项目不变得更加复杂时，你可能需要设置一个仓库代理。在企业环境中，这是相当普遍的。而对于一个开放源码项目而言，看起来则有点小题大做了。 <br><sup>[<a href="#N15329" name="ftn.N15329" class="para">17</a>] </sup>If you want to shield your project from the downtimes of Maven Central things get more complicated. You probably want to set-up a repository proxy for this. In an enterprise environment this is rather common. For an open source project it looks like overkill.</p>
    </div>
   </div>
  </div>
  <div class="navfooter">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="buildDashboard_plugin.html" title="第四十九章. Build Dashboard 插件">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="artifact_management.html" title="第五十一章. 发布构件">下一章</a>
    </div>
   </div>
  </div>
 </body>
</html>
